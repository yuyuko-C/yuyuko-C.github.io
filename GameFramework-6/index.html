<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Game Framework - 资源管理 | 雪の亡霊</title><meta name="author" content="幽幽墨染，樱树花开"><meta name="copyright" content="幽幽墨染，樱树花开"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#7B73BE"><meta name="description" content="资源模块写的东西巨~~~~TM多. E大, 你真是个魔鬼.   资源流程由于 GF 文档的缺失, 很多信息我们无法直接获取, 因此 StarForce 成了了解资源模块设计思想的唯一途径. 直接进入资源模块会导致非常多的未知信息, 进而无法进行下去. 资源模块由于非常复杂, 强行分析是非常容易迷失的. 所以第一步先了解知道 StarForce 的资源使用方法, 才能在后面的分析中不被不确定的东西阻">
<meta property="og:type" content="article">
<meta property="og:title" content="Game Framework - 资源管理">
<meta property="og:url" content="https://yuyuko-c.github.io/GameFramework-6/index.html">
<meta property="og:site_name" content="雪の亡霊">
<meta property="og:description" content="资源模块写的东西巨~~~~TM多. E大, 你真是个魔鬼.   资源流程由于 GF 文档的缺失, 很多信息我们无法直接获取, 因此 StarForce 成了了解资源模块设计思想的唯一途径. 直接进入资源模块会导致非常多的未知信息, 进而无法进行下去. 资源模块由于非常复杂, 强行分析是非常容易迷失的. 所以第一步先了解知道 StarForce 的资源使用方法, 才能在后面的分析中不被不确定的东西阻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b">
<meta property="article:published_time" content="2023-03-08T18:07:13.000Z">
<meta property="article:modified_time" content="2023-04-24T16:19:09.302Z">
<meta property="article:author" content="幽幽墨染，樱树花开">
<meta property="article:tag" content="Game Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuyuko-c.github.io/GameFramework-6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Game Framework - 资源管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-25 00:19:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#7B73BE')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#7B73BE')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/yuyuko_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雪の亡霊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Game Framework - 资源管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-08T18:07:13.000Z" title="发表于 2023-03-09 02:07:13">2023-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-24T16:19:09.302Z" title="更新于 2023-04-25 00:19:09">2023-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/Game-Framework/">Game Framework</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Game Framework - 资源管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>资源模块写的东西巨~~~~TM多. E大, 你真是个魔鬼.  </p>
<h1 id="资源流程"><a href="#资源流程" class="headerlink" title="资源流程"></a>资源流程</h1><p>由于 GF 文档的缺失, 很多信息我们无法直接获取, 因此 StarForce 成了了解资源模块设计思想的唯一途径. 直接进入资源模块会导致非常多的未知信息, 进而无法进行下去. 资源模块由于非常复杂, 强行分析是非常容易迷失的. 所以第一步先了解知道 StarForce 的资源使用方法, 才能在后面的分析中不被不确定的东西阻碍.</p>
<ul>
<li>编辑器模式 : ProcedureLaunch -&gt; ProcedureSplash -&gt; ProcedurePreload -&gt; ProcedureChangeScene</li>
<li>单机模式 : ProcedureLaunch -&gt; ProcedureSplash -&gt; ProcedureInitResources -&gt; ProcedurePreload -&gt; ProcedureChangeScene</li>
<li>可更新模式 : ProcedureLaunch -&gt; ProcedureSplash -&gt; ProcedureCheckVersion -&gt; ProcedureUpdateVersion -&gt; ProcedureVerifyResources -&gt; ProcedureCheckResources -&gt; ProcedureUpdateResources -&gt; ProcedurePreload -&gt; ProcedureChangeScene</li>
</ul>
<p>三种模式中公共的流程部分我就不提了. </p>
<ul>
<li>编辑器模式 : 完全不涉及到资源方面的处理. 使用了 <code>UnityEditor.AssetDatabase</code> 进行资源加载.</li>
<li>单机模式 : 借助 <code>ResourceManager</code> 的子类 <code>ResourceIniter</code> 执行资源初始化工作, 由于单机模式的所有资源均是打包进软体的，所以其主要内容是读取并解析在资源打包时生成的 GameFrameworkVersion.dat 文件， 这个文件存储了所有打包的资源信息和关联信息。</li>
<li>可更新模式:<ul>
<li><code>ProcedureCheckVersion</code> : 向服务器请求版本文件信息 Version.txt, 其为 Json 格式. 解析后获取是否强更, 如果不强更就是热更. 热更模式下, 在下一帧进入下一个流程. 值得一提的是,  此流程没有校验软件的服务器版本与本地版本是否一致, 服务器设置强更就是进入重装的死循环. 为了避免这个问题, 不同版本的包体检查版本的 URL 需要不一致, 尤其是需要强更的版本和不需要强更的版本要错开. 为了显式表明这一点, 可以把版本写到 Version.txt 的文件名中.</li>
<li><code>ProcedureUpdateVersion </code> : 通过反序列化 Version.txt 得到服务器中最新资源信息文件 GameFrameworkVersion.dat 的 URL 并下载到本地</li>
<li><code>ProcedureVerifyResources </code> : 解析读写路径下的 GameFrameworkList.dat, 将所有资源文件的信息写入到 <code>m_VerifyInfos</code>. 然后在 <code>Update</code> 中对资源进行验证, 得到读写路径下本地存在且与服务器资源相同的的资源列表覆盖原始的 GameFrameworkList.dat. 读写路径没有资源列表文件的时候直接进入下一流程.</li>
<li><code>ProcedureCheckResources </code> : 对下载下来的 GameFrameworkVersion.dat, 读写路径下的 GameFrameworkList.dat 和 只读路径下的 GameFrameworkList.dat 进行解析. 将所有文件信息存入 <code>m_CheckInfos</code> . 然后筛选出当前需要使用的资源信息, 并同时于磁盘和文件系统中清除不需要使用的资源. 对于筛选后为空的资源组也会被一并删除. 此流程会根据资源状态确实资源是否已经准备就绪和是否需要更新. </li>
<li><code>ProcedureUpdateResources </code> : 得到上个流程需要更新的资源的结果进行更新. 从服务器的资源文件夹 URL 获取对应的资源路径下载下来. 使用文件系统的资源会合并到文件系统文件并删除原始文件. 所有待更新更新完毕后会重新在读写路径生成 GameFrameworkList.dat 供下次使用. 随后进入下个流程.</li>
</ul>
</li>
</ul>
<p>流程与使用的类的对应关系为</p>
<table>
<thead>
<tr>
<th>流程</th>
<th>使用的类</th>
</tr>
</thead>
<tbody><tr>
<td>ProcedureInitResources</td>
<td>ResourceIniter</td>
</tr>
<tr>
<td>ProcedureCheckVersion</td>
<td>VersinListProcessor</td>
</tr>
<tr>
<td>ProcedureUpdateVersion</td>
<td>VersinListProcessor</td>
</tr>
<tr>
<td>ProcedureVerifyResources</td>
<td>ResourceVerifier</td>
</tr>
<tr>
<td>ProcedureCheckResources</td>
<td>ResourceChecker</td>
</tr>
<tr>
<td>ProcedureUpdateResources</td>
<td>ResourceUpdater</td>
</tr>
</tbody></table>
<h1 id="资源打包"><a href="#资源打包" class="headerlink" title="资源打包"></a>资源打包</h1><p>Unity 打 AB 包本身的内容相当简单, 使用 <code> BuildPipeline.BuildAssetBundles</code> 即可完成 AB 包的构建. 该方法将根据传入的参数构建AssetBundle，并返回一个AssetBundleManifest对象，该对象包含了构建完成的AssetBundle的清单信息，包括AssetBundle的名称、依赖项等。如果构建失败，该方法将返回null。</p>
<p>该方法需要四个参数：</p>
<ol>
<li>outputPath：表示AssetBundle的输出路径。</li>
<li>builds：表示AssetBundle的构建信息，包括AssetBundle的名称、包含的Asset等。</li>
<li>assetBundleOptions：表示AssetBundle的构建选项，例如是否压缩、是否强制重新构建等。</li>
<li>targetPlatform：表示打包平台。</li>
</ol>
<p>GF 是使用 <code>ResourceBuilder</code> 作为打包工具的窗口, <code>ResourceBuilderController</code> 作为打包工具的本体, 这里通过命名也可以看出是 MVC 思想. 但 <code>ResourceBuilderController</code> 也仅仅是资源打包的一半江山, 另外一半是 <code>ResourceEditor</code> , 只有一点点被 <code>ResourcePackBuilderController</code> 占据了. </p>
<p>注: 由于 <code>ResourceBuilderController</code> 在执行时会一带执行<code>ResourceAnalyzerController</code>, 再加上 <code>ResourceAnalyzer</code>  只是一个可视化工具, 不产生实际效果, 所以将之归到 <code>ResourceBuilderController</code> 之下.</p>
<h2 id="ResourceCollection"><a href="#ResourceCollection" class="headerlink" title="ResourceCollection"></a>ResourceCollection</h2><p> <code>ResourceCollection</code> 是 GF 打包的信息, 所有打包工具都围绕着这个文件展开. <code>ResourceCollection</code> 对应着 GameFramework&#x2F;Configs&#x2F;ResourceCollection.xml 文件, <code>ResourceEditor</code> 负责生成 ResourceCollection.xml, <code>ResourceAnalyzerController</code> 负责对 ResourceCollection.xml 的资源进行完整性检查. <code>ResourceBuilderController</code> 负责将搜集到的所有资源信息搜集起来传入 <code>BuildPipeline.BuildAssetBundles</code> 构建 AB 包, 并使用 <code>FileSystem</code> 收纳 AB 包.</p>
<h3 id="Asset-与-Resource"><a href="#Asset-与-Resource" class="headerlink" title="Asset 与 Resource"></a>Asset 与 Resource</h3><p><code>ResourceCollection</code> 依赖两个很重要的类 <code>Asset</code> 和 <code>Resource</code>, 这两个类在 GF 的设计中对应着 Unity 的 Asset(资产) 和 <code>AssetBundle</code>. 同时字段也能完全容纳 ResourceCollection.xml 中的属性. 但 E 大为了方便使用声明了其他公开属性使得其不能作为数据模型用来序列化和反序列化, 最终手写了持久化. 这两个类主要是用于反序列化 ResourceCollection.xml 的内容的. </p>
<ul>
<li><p>如何避免重复的打包资产打包</p>
<ul>
<li><code>Resource</code>  的 <code>AssignAsset</code> 函数是往其中添加 <code>Asset</code> 的函数, 每个 <code>Asset</code> 都记录了自己所属的 <code>Resource</code>, 在这个函数中会判断 <code>Resource</code> 是否为 <code>null</code>, 如果不为 <code>null</code> 就会调用 <code>Resource</code> 的 <code>UnAssignAsset</code> 解除之前 <code>Resource</code> 对 <code>Asset</code> 的引用.</li>
</ul>
</li>
</ul>
<h2 id="ResourceBuilderController"><a href="#ResourceBuilderController" class="headerlink" title="ResourceBuilderController"></a>ResourceBuilderController</h2><p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset/img/GameFramework-6.0.jpg" alt="GameFramework-6.0"></p>
<p>在 <code>ResouceBuilderController</code> 中的 <code>Load</code> 与 <code>Save</code> 方法是对界面显示参数进行持久化的函数. 使用的持久化文件为 GameFramework&#x2F;Configs&#x2F;ResourceBuilder.xml. 读取配置文件初始化信息后就不再使用, 后续读取信息使用反序列化的结果. 在构造函数中, 使用反射的方法将  <code>ICompressionHelper</code> 压缩辅助器和 <code>IBuildEventHandler</code> 构建事件的子类的类名写入到数组中用于窗口选择与后续反射创建实例. <code>ICompressionHelper</code>用于初始化压缩工具,  <code>IBuildEventHandler</code> 用于响应事件, 真正用于打包的函数是 <code>BuildResource</code>.</p>
<p> <code>BuildResource</code> 由多个部分构成, 它们之间的结构如下:</p>
<blockquote>
<ul>
<li>BuildResource - public<ul>
<li>BuidResource - private<ul>
<li>ProcessAssetBundle</li>
<li>ProcessBinary</li>
<li>ProcessPackageVersionList</li>
<li>ProcessUpdatableVersionList</li>
<li>ProcessReadOnlyVersionList</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>各个函数的作用如下:</p>
<blockquote>
<ul>
<li>BuildResource - public<ul>
<li>初始化文件夹路径和打包报告后读取  GameFramework&#x2F;Configs&#x2F;ResourceCollection.xml 文件, 如果读取失败会提醒先使用 <code>ResourceEditor</code> 生成文件, 在打包前会执行 <code>m_ResourceAnalyzerController.Analyze()</code> 进行资源完整性校验. 如果通过则为 AB 包搜集信息, 最后执行 BuidResource - private</li>
</ul>
</li>
<li>BuidResource - private <ul>
<li>初始化平台的文件夹路径后清空 working path, 之后在 working path 构建 AB 包 然后初始化 <code>FileSystem</code> , 最后按顺序执行旗下所有函数.</li>
</ul>
</li>
<li>ProcessAssetBundle<ul>
<li>读取 AB 包文件, 得到文件长度和哈希值并将二者的压缩长度和压缩哈希也设定同等值, 随后根据打包时设置的 <code>LoadType</code> 执行对应的加密步骤, 最后给到 <code>ProcessOutput</code> 输出</li>
</ul>
</li>
<li>ProcessBinary<ul>
<li>和 ProcessAssetBundle 的处理几乎一致,但让人不解的地方在 <code>string assetName = resourceData.GetAssetNames()[0];</code> 这句代码, 为何只取第一个值? 是二进制的处理方式下只会有一个资源的意思吗? 由于 GF 中并没有给出相应的范例, 如果没有猜错的话, 这就所有的资源都在一个文件里放着, 就像 <code>FileSystem</code> 那样.</li>
</ul>
</li>
<li>ProcessPackageVersionList<ul>
<li>将为 AB 包搜集的信息转换成 <code>PackageVersionList</code> 的里的对应类型, 随后拼成一个 <code>PackageVersionList</code> , 再使用 <code>PackageVersionListSerializer</code> 进行转换</li>
</ul>
</li>
<li>ProcessUpdatableVersionList<ul>
<li>将为 AB 包搜集的信息转换成 <code>UpdatableVersionList</code> 的里的对应类型, 随后拼成一个 <code>UpdatableVersionList</code> , 再使用 <code>UpdatableVersionListSerializer</code> 进行转换, 最后使用 <code>Utility.Compression</code> 进行压缩处理.</li>
</ul>
</li>
<li>ProcessReadOnlyVersionList<ul>
<li>将为 AB 包搜集的信息转换成 <code>LocalVersionList</code> 的里的对应类型, 随后拼成一个 <code>LocalVersionList</code> , 再使用 <code>ReadOnlyVersionListSerializer</code> 进行转换</li>
</ul>
</li>
<li>ProcessOutput - extra<ul>
<li>根据设计将 <code>Resource</code> 文件存到不同的文件夹. Full 文件夹存 <code>Resource</code> 形式的资源, Package 和 Packed 根据是否存入 <code>FileSystem</code> 的设置存 <code>Resource</code> 或 <code>FileSystem</code> 形式的资源. 这里能看到 Full 文件夹里 <code>Resource</code> 形式的资源的命名规则, 这个记住, 要考.</li>
</ul>
</li>
</ul>
</blockquote>
<p>最终将资源打包成了三种形式</p>
<ul>
<li>包裹了单个 <code>AssetBudle</code> 的 <code>Resource</code></li>
<li>包裹了多个 <code>Resource</code> 的 <code>FileSystem</code></li>
<li>存储了所有 <code>Resource</code> 和 <code>FileSystem</code> 信息和各个层面的资源索引的 GameFrameworkVersion.dat 和 GameFrameworkList.dat. GameFrameworkVersion.dat 还另外存储了  <code>Asset</code> 信息.</li>
</ul>
<h3 id="LocalVersionList、UpdatableVersionList-和-PackageVersionList"><a href="#LocalVersionList、UpdatableVersionList-和-PackageVersionList" class="headerlink" title="LocalVersionList、UpdatableVersionList 和 PackageVersionList"></a>LocalVersionList、UpdatableVersionList 和 PackageVersionList</h3><p><code>LocalVersionList</code> 和 <code>UpdatableVersionList</code> 是成对出现的, 用于可更新模式. 分别对应着打包文件夹中 Packed 文件夹和 Full 文件夹的内容.</p>
<p><code>PackageVersionList</code> 是用于单机模式下的内容, 对应着打包文件夹中 Package 文件夹.</p>
<p><code>LocalVersionList</code> 只存储了 <code>Resource</code> 和 <code>FileSystem</code> 的信息. <code>UpdatableVersionList</code> 存储了 <code>Asset</code>&#x2F;<code>Resource</code>&#x2F;<code>FileSystem</code>&#x2F;<code>ResourceGroup</code> 的信息.</p>
<p><code>PackageVersionList</code> 存储了 <code>Asset</code>&#x2F;<code>Resource</code>&#x2F;<code>FileSystem</code>&#x2F;<code>ResourceGroup</code> 的信息.</p>
<h4 id="PackageVersionList-和-UpdatableVersionList"><a href="#PackageVersionList-和-UpdatableVersionList" class="headerlink" title="PackageVersionList 和 UpdatableVersionList"></a>PackageVersionList 和 UpdatableVersionList</h4><p>可以看到 <code>PackageVersionList</code> 和 <code>UpdatableVersionList</code>  存储着完全相同的类型信息, 那他们的区别是什么呢</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>PackageVersionList</th>
<th>UpdatableVersionList</th>
</tr>
</thead>
<tbody><tr>
<td>本体文件</td>
<td>没有压缩后的信息</td>
<td>有压缩后的信息</td>
</tr>
<tr>
<td>记录的文件</td>
<td>以 FileSystem 的形式存储</td>
<td>以 Resource 的形式存储</td>
</tr>
</tbody></table>
<p><code>UpdatableVersionList</code> 为了便于网络传输选择了压缩, <code>PackageVersionList</code> 为了提高读取效率选择了不压缩. 在 GF 中虽然 <code>UpdatableVersionList</code> 中带有了压缩信息, 但根据我们之前的了解, 实际进行压缩了的资源只有 <code>UpdatableVersionList</code> 序列化的本体, 也就是 GameFrameworkVersion.dat 文件, AB 包虽然也有压缩标记但实际并未使用.</p>
<h4 id="LocalVersionList和UpdatableVersionList"><a href="#LocalVersionList和UpdatableVersionList" class="headerlink" title="LocalVersionList和UpdatableVersionList"></a>LocalVersionList和UpdatableVersionList</h4><p><code>LocalVersionList</code> 存储 <code>Resource</code> 是为了和 <code>UpdatableVersionList</code> 做对比知道应该下载和删除哪些资源信息.</p>
<h3 id="AssetData-与-ResourceData"><a href="#AssetData-与-ResourceData" class="headerlink" title="AssetData 与 ResourceData"></a>AssetData 与 ResourceData</h3><p>这两个类是私有的类中类, 只能用于 <code>ResourceBuilderController</code>, 由 <code>Asset</code> 和 <code>Resource</code> 转化而来. 多出来一些验证信息用于打包, 例如长度和哈希值.</p>
<h3 id="VersionListData"><a href="#VersionListData" class="headerlink" title="VersionListData"></a>VersionListData</h3><p>这个类完全是为了传递 <code>ProcessUpdatableVersionList</code>  的信息到 <code>BuildResource - private</code>, 把 <code>m_BuildReport</code> 和 <code>m_BuildEventHandler</code> 的调用聚集到 <code>BuildResource - private</code> . 属于为了规范而出现的类.</p>
<h2 id="ResourceAnalyzerController"><a href="#ResourceAnalyzerController" class="headerlink" title="ResourceAnalyzerController"></a>ResourceAnalyzerController</h2><h3 id="DependecyData"><a href="#DependecyData" class="headerlink" title="DependecyData"></a>DependecyData</h3><p>作为 <code>ResourceAnalyzer</code> 的界面的显示数据而声明, 而后因为 <code>ResourceAnalyzerController</code> 作为 <code>ResourceBuilderController</code> 的成员变量顺便给了 <code>ResourceBuilderController</code> 使用获得依赖资产.</p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnalyzeAsset</span>(<span class="params"><span class="built_in">string</span> assetName, Asset hostAsset, DependencyData dependencyData, HashSet&lt;<span class="built_in">string</span>&gt; scriptAssetNames</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] dependencyAssetNames = AssetDatabase.GetDependencies(assetName, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> dependencyAssetName <span class="keyword">in</span> dependencyAssetNames)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (scriptAssetNames.Contains(dependencyAssetName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dependencyAssetName == assetName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dependencyAssetName.EndsWith(<span class="string">&quot;.unity&quot;</span>, StringComparison.Ordinal))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 忽略对场景的依赖</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 资源戳, 对处理过的资源跳过避免循环依赖</span></span><br><span class="line">        Stamp stamp = <span class="keyword">new</span> Stamp(hostAsset.Name, dependencyAssetName);</span><br><span class="line">        <span class="keyword">if</span> (m_AnalyzedStamps.Contains(stamp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_AnalyzedStamps.Add(stamp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> guid = AssetDatabase.AssetPathToGUID(dependencyAssetName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(guid))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogWarning(Utility.Text.Format(<span class="string">&quot;Can not find guid by asset &#x27;&#123;0&#125;&#x27;.&quot;</span>, dependencyAssetName));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Asset asset = m_ResourceCollection.GetAsset(guid);</span><br><span class="line">        <span class="keyword">if</span> (asset != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dependencyData.AddDependencyAsset(asset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里就是有 dependencyAssetName 这个资产但是没打包进来</span></span><br><span class="line">            dependencyData.AddScatteredDependencyAsset(dependencyAssetName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录哪些资产依赖未打包的资产</span></span><br><span class="line">            List&lt;Asset&gt; scatteredAssets = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_ScatteredAssets.TryGetValue(dependencyAssetName, <span class="keyword">out</span> scatteredAssets))</span><br><span class="line">            &#123;</span><br><span class="line">                scatteredAssets = <span class="keyword">new</span> List&lt;Asset&gt;();</span><br><span class="line">                m_ScatteredAssets.Add(dependencyAssetName, scatteredAssets);</span><br><span class="line">            &#125;</span><br><span class="line">            scatteredAssets.Add(hostAsset);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将此依赖资产作为主资产再次搜索.</span></span><br><span class="line">            AnalyzeAsset(dependencyAssetName, hostAsset, dependencyData, scriptAssetNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ResourceEditorController"><a href="#ResourceEditorController" class="headerlink" title="ResourceEditorController"></a>ResourceEditorController</h2><p>这个就是 <code>ResourceCollection</code> 套了个壳, 在编辑器界面对 <code>ResourceCollection</code> 进行修改.</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p><code>ResourceBuilderController.ResourceData</code> 的 <code>m_Codes</code> 和 <code>ResourceCode</code> 类可以删除,  <code>ResourceCode</code> 类的成员可以直接写入到 <code>ResourceData</code> 中, 压根不存在需要 <code>List</code> 的情况.</p>
</li>
<li><p>资源打包与资源加载的对应问题</p>
<p>使用了 <code>AssetUtility</code> 获取到编辑器模式下的路径. 编辑器模式下自然没有问题, 在打包后是如何解决的呢? E 大在打包的时候使用的路径同样也永远是编辑器下的路径, 使得这个路径无论是编辑器模式还是打包模式都可以使用. 版本信息中记录了 Resource 里留存的 Asset, 在恢复的时候将 Resource 作为成员变量存入 Asset 中即可知道 Asset 所属 Resource 从而检查 Resource 状态并通过 Resource 加载资产.</p>
</li>
<li><p><code>LocalVersionList</code> 为什么没有记录 Asset 的信息? </p>
<p>因为无论如何都会有 <code>UpdatableVersionList</code></p>
</li>
</ol>
<h1 id="资源初始化"><a href="#资源初始化" class="headerlink" title="资源初始化"></a>资源初始化</h1><p>在以打包的模式运行时都需要对资源进行初始化, 主要的工作就是反序列化资源文件信息列表还原打包时的各种配置. 因为单机模式下资源跟随包体是属于全部准备好的状态, 因此这个过程尤为纯粹.</p>
<p><code>ResourceIniter</code> 中首先对只读路径下的 GameFrameworkVersion.dat 文件进行了读取, 随后使用相同的序列化工具进行了反序列化还原成 <code>PackageVersionList</code>, 对所有的内部信息再度还原并写入 <code>ResourceManager</code> 的成员字典中.</p>
<p>此时资源就已经初始化完成了, 对于每个要加载的资源, 都对应了一个 <code>AssetInfo</code>,  <code>AssetInfo</code> 中记录了 <code>ResourceName</code>, 每个 <code>ResourceName</code> 又能得到对应的 <code>Resource</code> 也就是 AB 包的马甲, 所以顺势就可以进行资源加载了.</p>
<h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1><p>资源加载其实是 <code>ResourceManager</code>  调用了其成员 <code>ResourceLoader</code>  的资源加载方法. 它们可以分为三类 <code>ResourceLoader.LoadAsset</code>,  <code>ResourceLoader.LoadScene</code>,  <code>ResourceLoader.LoadBinary</code>. 他们前两者的区别是往 <code>TaskPool</code> 里放入了特定的 <code>Task</code>. 分别是 <code>LoadAssetTask</code>, <code>LoadDependencyTask</code>  和 <code>LoadSceneTask</code>, 而 <code>ResourceLoader.LoadBinary</code> 则完全脱离 <code>Task</code> 体系存在. </p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在进入到这一块之前, 先简单认识几个类. 因为这几个类的命名具有很强的相似性, 所以提前说明, 明晰他们的作用.</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset/img/GameFramework-6.1.jpg" alt="GameFramework-6.1"></p>
<h3 id="ResourceName"><a href="#ResourceName" class="headerlink" title="ResourceName"></a>ResourceName</h3><p>可以完全理解为资源路径, 如此设计是因为</p>
<ul>
<li><p>要将此变量当做字符串使用. 字符串虽说是引用类型, 但是是一种不可变的引用类型, 表现类似于值类型, 每次传递都会生成一个副本, 所以定义为 <code>struct</code></p>
</li>
<li><p>要使用 <code>Name</code> 和 <code>FullName</code> 两种类型的路径. Unity 的资源加载使用的路径是不需要后缀名的, 所以需要使用 <code>Name</code> 属性, 而 <code>FullPath</code> 是携带后缀名的, 在加载数据的时候需要使用这个路径.</p>
</li>
<li><p>减少字符串的生成, 优化GC.  可以看到在内部实现里,  无论是哈希, 等于还是比较大小的接口实现, 均未采用 <code>FullName</code> 方法 <code>FullName</code> 是里面唯一一个会拼接字符串的方法. 而且 <code>FullName</code> 函数是按需拼接, 甚至用静态字典缓存结果避免再次拼接</p>
</li>
</ul>
<h3 id="AssetInfo-与-ResourceInfo"><a href="#AssetInfo-与-ResourceInfo" class="headerlink" title="AssetInfo 与 ResourceInfo"></a>AssetInfo 与 ResourceInfo</h3><p>通过比较成员变量可以发现其中的差别, 虽然不显眼, 但决定其本质区别的变量是 <code>m_DependencyAssetNames</code>. <code>m_DependencyAssetNames</code> 来源于 GF 打包工具给出的信息, 这个信息记录了 Unity 专有资源里的依赖信息, 即在 Inspector 界面挂载的资产都会归类到依赖资源里 .  也就是说 <code>AssetInfo </code> 是记录的资源之间的关系,   <code>ResourceInfo</code> 则是记录的资源文件的信息.</p>
<h3 id="AssetObject-和-ResourceObject"><a href="#AssetObject-和-ResourceObject" class="headerlink" title="AssetObject 和 ResourceObject"></a>AssetObject 和 ResourceObject</h3><p>这两个类继承自 <code>ObjectBase</code> 这个对象池专用的类, 也就意味着这两个类是用于对象池的, 关于对象池的部分我们下期再讲.</p>
<p>这里先剧透一下, 这两个分别对应资产和 AB 包, <code>AssetObject</code> 的 <code>m_Resource</code> 是记录所属 AB 包的.</p>
<h2 id="ResourceLoader-LoadResourceTaskBase"><a href="#ResourceLoader-LoadResourceTaskBase" class="headerlink" title="ResourceLoader.LoadResourceTaskBase"></a>ResourceLoader.LoadResourceTaskBase</h2><p> <code>ResourceLoader.LoadAsset</code>,  <code>ResourceLoader.LoadScene</code> 离不开 <code>LoadResourceTaskBase</code>.</p>
<p> <code>LoadResourceTaskBase</code> 这个继承自 <code>TaskBase</code> 的对象将承载资源加载里的绝大多数功能.</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset/img/GameFramework-6.2.jpg" alt="GameFramework-6.2"></p>
<p><code>LoadResourceTaskBase</code> 与其他 Task 最大的不同就是 <code>LoadResourceTaskBase</code> 有了回调函数, 不再单纯的作为信息的记录存在. 产生区别的原因就是将任务的回调函数存储在了任务上而不是管理器上. <code>LoadResourceAgent</code> 会调用  <code>LoadResourceTaskBase</code> 的回调函数, 继而调用任务下达时的回调函数.</p>
<p>先预览一下他们的调用的对应关系</p>
<table>
<thead>
<tr>
<th>LoadResourceTaskBase</th>
<th>LoadResourceAgent</th>
</tr>
</thead>
<tbody><tr>
<td>LoadMain</td>
<td>OnResourceObjectReady</td>
</tr>
<tr>
<td>OnLoadAssetSuccess</td>
<td>OnAssetObjectReady</td>
</tr>
<tr>
<td>OnLoadAssetFailure</td>
<td>OnError</td>
</tr>
<tr>
<td>OnLoadAssetUpdate</td>
<td>OnLoadResourceAgentHelperUpdate</td>
</tr>
<tr>
<td>OnLoadDependencyAsset</td>
<td>无</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadMain</span>(<span class="params">LoadResourceAgent agent, ResourceObject resourceObject</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_ResourceObject = resourceObject;</span><br><span class="line">    agent.Helper.LoadAsset(resourceObject.Target, AssetName, AssetType, IsScene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到 <code>resourceObject.Target</code> 作为第一个参数传递到了 <code>LoadAsset</code> 函数中, 那就去 UGF 看看是什么.</p>
<p>在 <code>UGF</code> 的 <code>LoadAsset</code> 实现中, 首先就是将 <code>resource as AssetBundle</code>. 难道 <code>ResourceObject</code> 承载的是 <code>AssetBundle</code>? </p>
<p>不确定, 但可以先这么认为着. 那接下来就是 <code>AssetObject</code> 是什么了.</p>
<ul>
<li><p>关于 Asset</p>
<p>虽然之前说了 <code>AssetInfo</code> 是记录资源之间的依赖关系的, 而且 <code>LoadResourceTaskBase</code> 也有一个 <code>OnLoadDependencyAsset</code>, 从对象池中取出的 Asset 也是完整具备依赖资源的. 即便如此 <code>LoadResourceTaskBase</code> 的 <code>OnLoadAssetSuccess</code> 并不需要等到依赖资源加载完成才触发. 一个任务只能管一个资源.</p>
</li>
</ul>
<h2 id="ResourceLoader-LoadResourceAgent"><a href="#ResourceLoader-LoadResourceAgent" class="headerlink" title="ResourceLoader.LoadResourceAgent"></a>ResourceLoader.LoadResourceAgent</h2><p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset/img/GameFramework-6.3.jpg" alt="GameFramework-6.3"></p>
<p>这个类就是为处理 <code>LoadResourceTaskBase</code> 存在的, 它依赖 <code>ILoadResourceAgentHelper</code>, <code>IResourceHelper</code>, <code>ResourceLoader</code>. </p>
<p>再次回顾他们的对应关系</p>
<table>
<thead>
<tr>
<th>LoadResourceAgent</th>
<th>LoadResourceTaskBase</th>
</tr>
</thead>
<tbody><tr>
<td>OnResourceObjectReady</td>
<td>LoadMain</td>
</tr>
<tr>
<td>OnAssetObjectReady</td>
<td>OnLoadAssetSuccess</td>
</tr>
<tr>
<td>OnError</td>
<td>OnLoadAssetFailure</td>
</tr>
<tr>
<td>OnLoadResourceAgentHelperUpdate</td>
<td>OnLoadAssetUpdate</td>
</tr>
<tr>
<td>无</td>
<td>OnLoadDependencyAsset</td>
</tr>
</tbody></table>
<p>先看看这个画风突兀的 <code>OnError</code> 是怎么回事. 原来是只在 <code>OnLoadResourceAgentHelperError</code> 调用的函数啊, 删了转移! 再看看这个 <code>OnLoadDependencyAsset</code> 是怎么回事. 原来是只在  <code>LoadDependencyTask</code>  触发 <code>OnLoadAssetSuccess</code> 的时候调用. 主要是将依赖资源添加到主任务的依赖资源列表中. </p>
<p>可是依赖信息作为挂载在组件上的资源, 应该只会在组件中存在, 场景资源并不能挂组件也就不会有资源依赖信息才对, 可是为什么 <code>OnLoadDependencyAsset</code> 定义在了基类中呢? 我去实际考察才意识到, 场景也是有依赖信息的. 资源打包的所有东西都是预制体, 场景也是预制体, 而在场景中放置(实例化)的那些资源的所依赖的集合就是场景的依赖资源.</p>
<blockquote>
<p>我好像逐渐理解了一切~</p>
<p>不, 你没有 (捂嘴)</p>
</blockquote>
<h3 id="OnResourceObjectReady-与-OnAssetObjectReady"><a href="#OnResourceObjectReady-与-OnAssetObjectReady" class="headerlink" title="OnResourceObjectReady 与 OnAssetObjectReady"></a>OnResourceObjectReady 与 OnAssetObjectReady</h3><p>这两个函数很难不拿来对比, 在上面我们知道了 <code>ResourceObject</code> 很可能是 <code>AssetBundle</code> 的承载物, 那么在 <code>OnAssetObjectReady</code> 中做了什么呢?</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAssetObjectReady</span>(<span class="params">AssetObject assetObject</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Helper.Reset();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> asset = assetObject.Target;</span><br><span class="line">    <span class="keyword">if</span> (m_Task.IsScene)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ResourceLoader.m_SceneToAssetMap.Add(m_Task.AssetName, asset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_Task.OnLoadAssetSuccess(<span class="keyword">this</span>, asset, (<span class="built_in">float</span>)(DateTime.UtcNow - m_Task.StartTime).TotalSeconds);</span><br><span class="line">    m_Task.Done = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>assetObject.Target</code> 传递给了 <code>m_Task.OnLoadAssetSuccess</code> 的第二个参数 <code>asset</code>. 然后基于此传给了 <code>Task</code> 创建时赋予的外部回调函数. 因此, 我们只需要知道这个 <code>Target</code> 是什么即可. 调用 <code>OnAssetObjectReady</code> 的地方有两处, 其中一个位于 <code>Start</code>, 这条路行不通. 另外一个位于 <code>OnLoadResourceAgentHelperLoadComplete</code>.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadResourceAgentHelperLoadComplete</span>(<span class="params"><span class="built_in">object</span> sender, LoadResourceAgentHelperLoadCompleteEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AssetObject assetObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Task.IsScene)</span><br><span class="line">    &#123;</span><br><span class="line">        assetObject = m_ResourceLoader.m_AssetPool.Spawn(m_Task.AssetName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (assetObject == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">object</span>&gt; dependencyAssets = m_Task.GetDependencyAssets();</span><br><span class="line">        <span class="comment">// 将 LoadResourceAgentHelperLoadCompleteEventArgs 的 Asset 成员给到了 target 参数上</span></span><br><span class="line">        assetObject = AssetObject.Create(m_Task.AssetName, e.Asset, dependencyAssets, m_Task.ResourceObject.Target, m_ResourceHelper, m_ResourceLoader);</span><br><span class="line">        m_ResourceLoader.m_AssetPool.Register(assetObject, <span class="literal">true</span>);</span><br><span class="line">        m_ResourceLoader.m_AssetToResourceMap.Add(e.Asset, m_Task.ResourceObject.Target);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">object</span> dependencyAsset <span class="keyword">in</span> dependencyAssets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">object</span> dependencyResource = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (m_ResourceLoader.m_AssetToResourceMap.TryGetValue(dependencyAsset, <span class="keyword">out</span> dependencyResource))</span><br><span class="line">            &#123;</span><br><span class="line">                m_Task.ResourceObject.AddDependencyResource(dependencyResource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Can not find dependency resource.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_LoadingAssetNames.Remove(m_Task.AssetName);</span><br><span class="line">    <span class="comment">// 最后将 assetObject 给到 OnAssetObjectReady</span></span><br><span class="line">    OnAssetObjectReady(assetObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此我们清晰明了了, 只要看看这个 <code>LoadResourceAgentHelperLoadCompleteEventArgs</code> 的 <code>Asset</code> 是什么就可以了. 跳转到 UGF 中, 找到了这么一个函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateAssetBundleRequest</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_AssetBundleRequest != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_AssetBundleRequest.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_AssetBundleRequest.asset != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将 m_AssetBundleRequest.asset 作为 Create 的参数 asset 赋值到了其 Asset 成员变量上.</span></span><br><span class="line">                LoadResourceAgentHelperLoadCompleteEventArgs loadResourceAgentHelperLoadCompleteEventArgs = LoadResourceAgentHelperLoadCompleteEventArgs.Create(m_AssetBundleRequest.asset);</span><br><span class="line">                m_LoadResourceAgentHelperLoadCompleteEventHandler(<span class="keyword">this</span>, loadResourceAgentHelperLoadCompleteEventArgs);</span><br><span class="line">                ReferencePool.Release(loadResourceAgentHelperLoadCompleteEventArgs);</span><br><span class="line">                m_AssetName = <span class="literal">null</span>;</span><br><span class="line">                m_LastProgress = <span class="number">0f</span>;</span><br><span class="line">                m_AssetBundleRequest = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>m_AssetBundleRequest.asset</code> 的类型为 <code>UnityEngine.Object</code>, 由此我们可以推断 <code>AssetObject</code> 是用来承载 <code>UnityEngine.Object</code> 的.</p>
<blockquote>
<p>可, 人家 <code>AssetBundle</code> 也是 <code>UnityEngine.Object</code> 的子类耶, 怎会如此偏心….</p>
</blockquote>
<p>目前我们暂且可以得出结论, <code>ResourceOjbect</code> 是 AB 包的承载物, <code>AssetObject</code> 是被 AB 包打包的资产的承载物. 那顺势推理 <code>ResourceInfo</code> 是 AB 包的信息, <code>AssetInfo</code> 是被 AB 包打包的资产的信息应该不过分吧. </p>
<p>如何验证呢? 实例化 <code>ResourceInfo</code> 和  <code>AssetInfo</code> 的地方都在 <code>ResourceChecker.OnLoadPackageVersionListSuccess</code> 当中. 基于<a href="#ResourceBuilderController">ResourceBuilderController</a>中对 <code>PackageVersionList</code> 的介绍, 我们可以轻易的证实我们的猜想.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (PackageVersionList.Resource resource <span class="keyword">in</span> resources)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource.Variant != <span class="literal">null</span> &amp;&amp; resource.Variant != m_CurrentVariant)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResourceName resourceName = <span class="keyword">new</span> ResourceName(resource.Name, resource.Variant, resource.Extension);</span><br><span class="line">    <span class="built_in">int</span>[] assetIndexes = resource.GetAssetIndexes();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> assetIndex <span class="keyword">in</span> assetIndexes)</span><br><span class="line">    &#123;</span><br><span class="line">        PackageVersionList.Asset asset = assets[assetIndex];</span><br><span class="line">        <span class="built_in">int</span>[] dependencyAssetIndexes = asset.GetDependencyAssetIndexes();</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span>[] dependencyAssetNames = <span class="keyword">new</span> <span class="built_in">string</span>[dependencyAssetIndexes.Length];</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> dependencyAssetIndex <span class="keyword">in</span> dependencyAssetIndexes)</span><br><span class="line">        &#123;</span><br><span class="line">            dependencyAssetNames[index++] = assets[dependencyAssetIndex].Name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建AssetInfo</span></span><br><span class="line">        m_ResourceManager.m_AssetInfos.Add(asset.Name, <span class="keyword">new</span> AssetInfo(asset.Name, resourceName, dependencyAssetNames));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> fileSystemName = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_CachedFileSystemNames.TryGetValue(resourceName, <span class="keyword">out</span> fileSystemName))</span><br><span class="line">    &#123;</span><br><span class="line">        fileSystemName = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建ResourceInfo</span></span><br><span class="line">    m_ResourceManager.m_ResourceInfos.Add(resourceName, <span class="keyword">new</span> ResourceInfo(resourceName, fileSystemName, (LoadType)resource.LoadType, resource.Length, resource.HashCode, resource.Length, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">    defaultResourceGroup.AddResource(resourceName, resource.Length, resource.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p><code>Start</code> 函数看起来花里胡哨的, 但其实就做了四件事</p>
<ol>
<li>如果已经有现成的就获得并返回</li>
<li>如果依赖资源不齐全且没有现成的则无法执行</li>
<li>如果依赖资源齐全且没有现成的就通过 <code>AssetBundle</code> 加载</li>
<li>如果依赖资源齐全且没有现成的,而且 <code>AssetBundle</code> 也不存在则加载 <code>AssetBundle</code></li>
</ol>
<p>基于以上思路, 我将之进行了一点点整理使逻辑更清晰, 变成了下面的模样.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StartTaskStatus <span class="title">Start</span>(<span class="params">LoadResourceTaskBase task</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Task is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经有现成的就获得并返回</span></span><br><span class="line">    <span class="comment">// 如果依赖资源不齐全且没有现成的则无法执行</span></span><br><span class="line">    <span class="comment">// 如果依赖资源齐全且没有现成的就通过AssetBundle加载</span></span><br><span class="line">    <span class="comment">// 如果依赖资源齐全且没有现成的,而且AssetBundle也不存在则加载AssetBundle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_Task = task;</span><br><span class="line">    m_Task.StartTime = DateTime.UtcNow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到AB包信息</span></span><br><span class="line">    ResourceInfo resourceInfo = m_Task.ResourceInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AB包是否可加载, 这是一切的基础</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Task.StartTime = <span class="literal">default</span>(DateTime);</span><br><span class="line">        <span class="keyword">return</span> StartTaskStatus.HasToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试直接获取现成的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资产是否已经在加载中了, 在加载就直接返回, 任意一个资产只需要加载一次即可</span></span><br><span class="line">    <span class="comment">// 注意: 这里仅仅是资产和唐老师的不一样, 此处并未实例化. 资产是可以复用的.</span></span><br><span class="line">    <span class="keyword">if</span> (IsAssetLoading(m_Task.AssetName))</span><br><span class="line">    &#123;</span><br><span class="line">        m_Task.StartTime = <span class="literal">default</span>(DateTime);</span><br><span class="line">        <span class="keyword">return</span> StartTaskStatus.HasToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时资产并不处于加载状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取资产</span></span><br><span class="line">    AssetObject assetObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_Task.IsScene)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从资产对象池里得到资产, 只是获得了资产的引用, 并未从池中取出.</span></span><br><span class="line">        assetObject = m_ResourceLoader.m_AssetPool.Spawn(m_Task.AssetName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (assetObject != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加入对应表并返回给 Task 所属的回调函数使用</span></span><br><span class="line">        OnAssetObjectReady(assetObject);</span><br><span class="line">        <span class="keyword">return</span> StartTaskStatus.Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 资产不在加载中又获取不到资产则开始加载资产</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果依赖资源还没加载好则依然需要继续等待</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> dependencyAssetName <span class="keyword">in</span> m_Task.GetDependencyAssetNames())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m_ResourceLoader.m_AssetPool.CanSpawn(dependencyAssetName))</span><br><span class="line">            &#123;</span><br><span class="line">                m_Task.StartTime = <span class="literal">default</span>(DateTime);</span><br><span class="line">                <span class="keyword">return</span> StartTaskStatus.HasToWait;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖资源全都准备好了,将资产标记为正在加载的资源</span></span><br><span class="line">        s_LoadingAssetNames.Add(m_Task.AssetName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 资产加载需要AB包, 检查AB包是否还在加载</span></span><br><span class="line">        <span class="built_in">string</span> resourceName = resourceInfo.ResourceName.Name;</span><br><span class="line">        <span class="keyword">if</span> (IsResourceLoading(resourceName))</span><br><span class="line">        &#123;</span><br><span class="line">            m_Task.StartTime = <span class="literal">default</span>(DateTime);</span><br><span class="line">            <span class="keyword">return</span> StartTaskStatus.HasToWait;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AB包不处于加载状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从AB包对象池得到一个AB包</span></span><br><span class="line">        ResourceObject resourceObject = m_ResourceLoader.m_ResourcePool.Spawn(resourceName);</span><br><span class="line">        <span class="keyword">if</span> (resourceObject != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OnResourceObjectReady(resourceObject);</span><br><span class="line">            <span class="keyword">return</span> StartTaskStatus.CanResume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 标记AB包正在加载</span></span><br><span class="line">            s_LoadingResourceNames.Add(resourceName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始加载AB包,下面就是以各种方式加载AB包了</span></span><br><span class="line">            <span class="built_in">string</span> fullPath = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!s_CachedResourceNames.TryGetValue(resourceName, <span class="keyword">out</span> fullPath))</span><br><span class="line">            &#123;</span><br><span class="line">                fullPath = Utility.Path.GetRegularPath(Path.Combine(resourceInfo.StorageInReadOnly ? m_ReadOnlyPath : m_ReadWritePath, resourceInfo.UseFileSystem ? resourceInfo.FileSystemName : resourceInfo.ResourceName.FullName));</span><br><span class="line">                s_CachedResourceNames.Add(resourceName, fullPath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resourceInfo.LoadType == LoadType.LoadFromFile)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (resourceInfo.UseFileSystem)</span><br><span class="line">                &#123;</span><br><span class="line">                    IFileSystem fileSystem = m_ResourceLoader.m_ResourceManager.GetFileSystem(resourceInfo.FileSystemName, resourceInfo.StorageInReadOnly);</span><br><span class="line">                    m_Helper.ReadFile(fileSystem, resourceInfo.ResourceName.FullName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_Helper.ReadFile(fullPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resourceInfo.LoadType == LoadType.LoadFromMemory || resourceInfo.LoadType == LoadType.LoadFromMemoryAndQuickDecrypt || resourceInfo.LoadType == LoadType.LoadFromMemoryAndDecrypt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (resourceInfo.UseFileSystem)</span><br><span class="line">                &#123;</span><br><span class="line">                    IFileSystem fileSystem = m_ResourceLoader.m_ResourceManager.GetFileSystem(resourceInfo.FileSystemName, resourceInfo.StorageInReadOnly);</span><br><span class="line">                    m_Helper.ReadBytes(fileSystem, resourceInfo.ResourceName.FullName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_Helper.ReadBytes(fullPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Resource load type &#x27;&#123;0&#125;&#x27; is not supported.&quot;</span>, resourceInfo.LoadType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StartTaskStatus.CanResume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是, 虽然资产与依赖资产都是分开加载的, 理论上来说是无法保证其先后顺序的. 但因为 <code>Start</code> 函数在决定加载资产的时候对依赖资产做了检查, 所以保证了其依赖资产的完整性, 从对象池中取出来的都是依赖资产完整的资产. 具体情况在 <code>OnLoadResourceAgentHelperLoadComplete</code> 可以得到体现.</p>
<h2 id="ResourceLoader-LoadAsset"><a href="#ResourceLoader-LoadAsset" class="headerlink" title="ResourceLoader.LoadAsset"></a>ResourceLoader.LoadAsset</h2><p>这个函数并不难, 相关说明已经在下面代码的注释中得以体现.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载资源。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assetName&quot;&gt;</span>要加载资源的名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assetType&quot;&gt;</span>要加载资源的类型。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;priority&quot;&gt;</span>加载资源的优先级。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;loadAssetCallbacks&quot;&gt;</span>加载资源回调函数集。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userData&quot;&gt;</span>用户自定义数据。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadAsset</span>(<span class="params"><span class="built_in">string</span> assetName, Type assetType, <span class="built_in">int</span> priority, LoadAssetCallbacks loadAssetCallbacks, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceInfo resourceInfo = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span>[] dependencyAssetNames = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 检查资源极其依赖关系是否可加载, 并返回出资源信息与依赖资源名</span></span><br><span class="line">    <span class="keyword">if</span> (!CheckAsset(assetName, <span class="keyword">out</span> resourceInfo, <span class="keyword">out</span> dependencyAssetNames))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load asset &#x27;&#123;0&#125;&#x27;.&quot;</span>, assetName);</span><br><span class="line">        <span class="keyword">if</span> (loadAssetCallbacks.LoadAssetFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadAssetCallbacks.LoadAssetFailureCallback(assetName, resourceInfo != <span class="literal">null</span> &amp;&amp; !resourceInfo.Ready ? LoadResourceStatus.NotReady : LoadResourceStatus.NotExist, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资源是否以二进制的方式加载, 如果以二进制的方式加载则报错</span></span><br><span class="line">    <span class="comment">// 至于为啥不能是二进制方式加载我们后面再说.</span></span><br><span class="line">    <span class="keyword">if</span> (resourceInfo.IsLoadFromBinary)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load asset &#x27;&#123;0&#125;&#x27; which is a binary asset.&quot;</span>, assetName);</span><br><span class="line">        <span class="keyword">if</span> (loadAssetCallbacks.LoadAssetFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadAssetCallbacks.LoadAssetFailureCallback(assetName, LoadResourceStatus.TypeError, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给出资源加载的指令, 同时发起加载依赖资源的指令.</span></span><br><span class="line">    LoadAssetTask mainTask = LoadAssetTask.Create(assetName, assetType, priority, resourceInfo, dependencyAssetNames, loadAssetCallbacks, userData);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> dependencyAssetName <span class="keyword">in</span> dependencyAssetNames)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LoadDependencyAsset(dependencyAssetName, priority, mainTask, userData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load dependency asset &#x27;&#123;0&#125;&#x27; when load asset &#x27;&#123;1&#125;&#x27;.&quot;</span>, dependencyAssetName, assetName);</span><br><span class="line">            <span class="keyword">if</span> (loadAssetCallbacks.LoadAssetFailureCallback != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                loadAssetCallbacks.LoadAssetFailureCallback(assetName, LoadResourceStatus.DependencyError, errorMessage, userData);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_TaskPool.AddTask(mainTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CheckAsset函数中对资源加载类型做了检查, 走到这里说明资源是可以加载的</span></span><br><span class="line">    <span class="comment">// 但资源还未准备好说明资源加载模式是动态加载, 于是执行资源更新.</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ResourceManager.UpdateResource(resourceInfo.ResourceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CheckAsset"><a href="#CheckAsset" class="headerlink" title="CheckAsset"></a>CheckAsset</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CheckAsset</span>(<span class="params"><span class="built_in">string</span> assetName, <span class="keyword">out</span> ResourceInfo resourceInfo, <span class="keyword">out</span> <span class="built_in">string</span>[] dependencyAssetNames</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为out返回做准备, 保证任何时候返回都会是已赋值</span></span><br><span class="line">    resourceInfo = <span class="literal">null</span>;</span><br><span class="line">    dependencyAssetNames = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例行的字符串检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(assetName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过字符串获取AssetInfo, 需要注意的是这里使用的 ResourceManager 的方法</span></span><br><span class="line">    AssetInfo assetInfo = m_ResourceManager.GetAssetInfo(assetName);</span><br><span class="line">    <span class="keyword">if</span> (assetInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ResourceName获取ResourceInfo, 需要注意的是这里使用的 ResourceManager 的方法</span></span><br><span class="line">    resourceInfo = m_ResourceManager.GetResourceInfo(assetInfo.ResourceName);</span><br><span class="line">    <span class="keyword">if</span> (resourceInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dependency 来源于记录资源关系的 AssetInfo</span></span><br><span class="line">    dependencyAssetNames = assetInfo.GetDependencyAssetNames();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断资源模式, 动态加载永远返回true, 否则返回资源是否已准备就绪.</span></span><br><span class="line">    <span class="comment">// 资源准备就绪指的是资源是否已经在本地并且登记在资源信息字典里了.</span></span><br><span class="line">    <span class="keyword">return</span> m_ResourceManager.m_ResourceMode == ResourceMode.UpdatableWhilePlaying ? <span class="literal">true</span> : resourceInfo.Ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数没什么难以理解的地方, 需要注意的是这里使用的两个 <code>ResourceManager</code> 的方法. <code>ResourceLoader</code> 是 <code>ResourceManager</code> 的类中类, 而这两个方法使用的 <code>Dictionary</code> 是在另外一个 <code>ResourceManager</code> 的类中类 <code>ResourceChecker</code> 里进行初始化的, 两者都是将 <code>ResourceManager</code> 作为了自己的成员变量. 这个构思是很巧妙的, 非常值得学习:  <code>ResourceChecker</code> 帮  <code>ResourceManager</code> 初始化了变量, 函数定义在  <code>ResourceManager</code> 里, 然后使用这两个函数的地方在 <code>ResourceLoader</code> .  <code>ResourceManager</code> 作为两个类中类通信的桥梁而存在, 且恰好方便了其他模块对资源信息的获取.</p>
<p>不得不说, E大的做法真是让我开了眼了,  这人把私有变量这东西玩出了花, 我在其他地方压根没见过这么玩的. 首先是用于引用池的静态函数, 使得能对一个已经创建出来的实例直接赋值私有变量. 其次是类中类共用了静态私有成员变量, 最后是非静态的私有变量居然还能共用!!!(摔~) , 用法将自身传递到类中类使自己成为类中类的成员变量, 通过在类中类中给私有变量赋值改变原始的类里的成员变量. 这想法过于精妙, 尤其是第三种, 我找了半天都在 <code>ResourceManager</code> 里找到这个变量的初始化, 一般来说私有变量不就是在类里面初始化的吗? 一个恒定为空的私有变量为什么可以被使用? 如果不是发现了这一点, 这问题还会困扰我很久, 我不得不佩服的五体投地 (这就给E大磕一个).</p>
<h3 id="LoadDependencyAsset"><a href="#LoadDependencyAsset" class="headerlink" title="LoadDependencyAsset"></a>LoadDependencyAsset</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">LoadDependencyAsset</span>(<span class="params"><span class="built_in">string</span> assetName, <span class="built_in">int</span> priority, LoadResourceTaskBase mainTask, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mainTask == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Main task is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿主资源加载的步骤, 返回false留给外部报错</span></span><br><span class="line">    ResourceInfo resourceInfo = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span>[] dependencyAssetNames = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CheckAsset(assetName, <span class="keyword">out</span> resourceInfo, <span class="keyword">out</span> dependencyAssetNames))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿主资源加载的步骤, 返回false留给外部报错</span></span><br><span class="line">    <span class="keyword">if</span> (resourceInfo.IsLoadFromBinary)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下达依赖资源下载的任务</span></span><br><span class="line">    LoadDependencyAssetTask dependencyTask = LoadDependencyAssetTask.Create(assetName, priority, resourceInfo, dependencyAssetNames, mainTask, userData);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> dependencyAssetName <span class="keyword">in</span> dependencyAssetNames)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归加载依赖资源直至没有依赖资源</span></span><br><span class="line">        <span class="keyword">if</span> (!LoadDependencyAsset(dependencyAssetName, priority, dependencyTask, userData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_TaskPool.AddTask(dependencyTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿主资源加载的步骤</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ResourceManager.UpdateResource(resourceInfo.ResourceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ResourceLoader-LoadScene"><a href="#ResourceLoader-LoadScene" class="headerlink" title="ResourceLoader.LoadScene"></a>ResourceLoader.LoadScene</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载场景。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sceneAssetName&quot;&gt;</span>要加载场景资源的名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;priority&quot;&gt;</span>加载场景资源的优先级。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;loadSceneCallbacks&quot;&gt;</span>加载场景回调函数集。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userData&quot;&gt;</span>用户自定义数据。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> sceneAssetName, <span class="built_in">int</span> priority, LoadSceneCallbacks loadSceneCallbacks, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceInfo resourceInfo = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span>[] dependencyAssetNames = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CheckAsset(sceneAssetName, <span class="keyword">out</span> resourceInfo, <span class="keyword">out</span> dependencyAssetNames))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load scene &#x27;&#123;0&#125;&#x27;.&quot;</span>, sceneAssetName);</span><br><span class="line">        <span class="keyword">if</span> (loadSceneCallbacks.LoadSceneFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadSceneCallbacks.LoadSceneFailureCallback(sceneAssetName, resourceInfo != <span class="literal">null</span> &amp;&amp; !resourceInfo.Ready ? LoadResourceStatus.NotReady : LoadResourceStatus.NotExist, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceInfo.IsLoadFromBinary)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load scene asset &#x27;&#123;0&#125;&#x27; which is a binary asset.&quot;</span>, sceneAssetName);</span><br><span class="line">        <span class="keyword">if</span> (loadSceneCallbacks.LoadSceneFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadSceneCallbacks.LoadSceneFailureCallback(sceneAssetName, LoadResourceStatus.TypeError, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LoadSceneTask mainTask = LoadSceneTask.Create(sceneAssetName, priority, resourceInfo, dependencyAssetNames, loadSceneCallbacks, userData);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> dependencyAssetName <span class="keyword">in</span> dependencyAssetNames)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LoadDependencyAsset(dependencyAssetName, priority, mainTask, userData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load dependency asset &#x27;&#123;0&#125;&#x27; when load scene &#x27;&#123;1&#125;&#x27;.&quot;</span>, dependencyAssetName, sceneAssetName);</span><br><span class="line">            <span class="keyword">if</span> (loadSceneCallbacks.LoadSceneFailureCallback != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                loadSceneCallbacks.LoadSceneFailureCallback(sceneAssetName, LoadResourceStatus.DependencyError, errorMessage, userData);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_TaskPool.AddTask(mainTask);</span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ResourceManager.UpdateResource(resourceInfo.ResourceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数基本和 <code>LoadAsset</code> 是一个模子里刻出来的, 唯一的区别就是从 <code>LoadAssetTask</code> 变成了 <code>LoadSceneTask</code>, 这两个 <code>Task</code> 唯一的区别就是标记资产是不是场景(通过 <code>IsScene</code> 属性)</p>
<p>在 UGF 的实现中, 我们也可以看到其不同, 如果不是场景就用 <code>AssetBundle</code> 加载, 如果是场景则用 <code>SceneManager</code> 加载.</p>
<h2 id="ResourceLoader-LoadBinary"><a href="#ResourceLoader-LoadBinary" class="headerlink" title="ResourceLoader.LoadBinary"></a>ResourceLoader.LoadBinary</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载二进制资源。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryAssetName&quot;&gt;</span>要加载二进制资源的名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;loadBinaryCallbacks&quot;&gt;</span>加载二进制资源回调函数集。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userData&quot;&gt;</span>用户自定义数据。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadBinary</span>(<span class="params"><span class="built_in">string</span> binaryAssetName, LoadBinaryCallbacks loadBinaryCallbacks, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceInfo resourceInfo = GetResourceInfo(binaryAssetName);</span><br><span class="line">    <span class="keyword">if</span> (resourceInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load binary &#x27;&#123;0&#125;&#x27; which is not exist.&quot;</span>, binaryAssetName);</span><br><span class="line">        <span class="keyword">if</span> (loadBinaryCallbacks.LoadBinaryFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadBinaryCallbacks.LoadBinaryFailureCallback(binaryAssetName, LoadResourceStatus.NotExist, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load binary &#x27;&#123;0&#125;&#x27; which is not ready.&quot;</span>, binaryAssetName);</span><br><span class="line">        <span class="keyword">if</span> (loadBinaryCallbacks.LoadBinaryFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadBinaryCallbacks.LoadBinaryFailureCallback(binaryAssetName, LoadResourceStatus.NotReady, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!resourceInfo.IsLoadFromBinary)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> errorMessage = Utility.Text.Format(<span class="string">&quot;Can not load binary &#x27;&#123;0&#125;&#x27; which is not a binary asset.&quot;</span>, binaryAssetName);</span><br><span class="line">        <span class="keyword">if</span> (loadBinaryCallbacks.LoadBinaryFailureCallback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loadBinaryCallbacks.LoadBinaryFailureCallback(binaryAssetName, LoadResourceStatus.TypeError, errorMessage, userData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceInfo.UseFileSystem)</span><br><span class="line">    &#123;</span><br><span class="line">        loadBinaryCallbacks.LoadBinarySuccessCallback(binaryAssetName, LoadBinaryFromFileSystem(binaryAssetName), <span class="number">0f</span>, userData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = Utility.Path.GetRemotePath(Path.Combine(resourceInfo.StorageInReadOnly ? m_ResourceManager.m_ReadOnlyPath : m_ResourceManager.m_ReadWritePath, resourceInfo.ResourceName.FullName));</span><br><span class="line">        m_ResourceManager.m_ResourceHelper.LoadBytes(path, m_LoadBytesCallbacks, LoadBinaryInfo.Create(binaryAssetName, resourceInfo, loadBinaryCallbacks, userData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能看到在这个函数中, 不使用二进制的方式加载的资源就会报错. 那二进制与非二进制加载到底有何不同呢. 追踪到 UGF 后发现二进制加载使用的是 <code>UnityWebRequest</code>…… 额, 这下确实给我整不会了. </p>
<p>在这个实现中, 其核心代码与上一篇提到的 <code>WebRequest</code> 部分高度相似, 感觉完全可以借用 <code>WebRequestManager</code> 作为替代, 至于为什么没用嘛, 是因为不方便传递回调函数. 早在 <a href="/GameFramework-4/" title="Game Framework - 任务异步">Game Framework - 任务异步</a> 我就提出了这个回调归属问题, 回调函数应该放在任务创建的时候存储在任务上. 当然, 即使不改动代码, 这个回调函数也并非完全不能传递. 这里简单做个演示.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> path = Utility.Path.GetRemotePath(Path.Combine(resourceInfo.StorageInReadOnly ? m_ResourceManager.m_ReadOnlyPath : m_ResourceManager.m_ReadWritePath, resourceInfo.ResourceName.FullName));</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(path, m_LoadBytesCallbacks, LoadBinaryInfo.Create(binaryAssetName, resourceInfo, loadBinaryCallbacks, userData));</span><br><span class="line">WebRequest.WebRequestManager m_WebRequestManager = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 通过匿名函数将回调传入WebRequestManager所属的委托, 为了方便取消可以将匿名函数声明成非匿名函数.这里就不做演示了</span></span><br><span class="line">m_WebRequestManager.WebRequestSuccess += (<span class="built_in">object</span> sender, WebRequest.WebRequestSuccessEventArgs args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    OnLoadBinarySuccess(path, args.GetWebResponseBytes(), <span class="number">0</span>, userData);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 但是最方便的肯定是在任务建立的时候传递回调函数.(因为需要多处改动才能实现, 此处为伪代码)</span></span><br><span class="line">m_WebRequestManager.AddWebRequest(path, callbacks);</span><br></pre></td></tr></table></figure>

<p>嘿嘿, 现在我们知道了为什么 <code>LoadAsset</code> 和 <code>LoadScene</code> 里为啥不能使用二进制的方式加载了吧.</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p><code>LoadResourceTaskBase</code> 与 <code>LoadResourceAgent</code> 破坏了访问权限的一致性.</p>
<p>参考其他 Agent, 均是由 Agent 获取 Task , 唯独 <code>LoadResourceTaskBase</code> 在 <code>LoadMain</code>里出现了 Agent 的变量. 也因此, <code>LoadMain</code> 里才出现里离谱的 <code>agent.Helper</code>. 一个 <code>Task</code> 居然不仅要知道 Agent, 还要知道 AgentHelper 了? 这在 Task 体系里也是独一份. 更更更离谱的是, 为了让 <code>LoadResourceTaskBase</code> 获取到这个 Helper, 特地在 <code>LoadResourceAgent</code> 声明了一个属性给他独享.</p>
<p>如何改动? 把 <code>LoadMain</code> 改成 <code>SetResourceObject</code> 或者直接把 <code>m_ResourceObject</code> 直接作为公开访问权限即可, <code>LoadMain</code> 函数说白了作用也仅此而已. 里面的 <code>agent.Helper.LoadAsset</code> 自然也就要挪到 <code>LoadResourceAgent</code> 里完成了.</p>
</li>
<li><p><code>IResourceHelper</code> 与 <code>ILoadResourceAgentHelper</code> 的同质化问题, 这两个可以合并成一个.</p>
<ol>
<li>二者同属于 <code>ResourceLoader</code></li>
<li>二者均有使用 <code>AssetBundle</code> 和 <code>UnityWebRequest</code> 的方法.</li>
<li>二者均不会在 <code>ResourceLoader</code> 以外的地方被使用</li>
</ol>
</li>
</ol>
<h1 id="资源更新"><a href="#资源更新" class="headerlink" title="资源更新"></a>资源更新</h1><h2 id="VersionListProcessor"><a href="#VersionListProcessor" class="headerlink" title="VersionListProcessor"></a>VersionListProcessor</h2><p><a href="#%E8%B5%84%E6%BA%90%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D">见资源流程介绍</a></p>
<h2 id="ResourceVerifier"><a href="#ResourceVerifier" class="headerlink" title="ResourceVerifier"></a>ResourceVerifier</h2><p><a href="#%E8%B5%84%E6%BA%90%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D">见资源流程介绍</a></p>
<h2 id="ResourceChecker"><a href="#ResourceChecker" class="headerlink" title="ResourceChecker"></a>ResourceChecker</h2><p><a href="#%E8%B5%84%E6%BA%90%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D">见资源流程介绍</a></p>
<h2 id="ResourceUpdater"><a href="#ResourceUpdater" class="headerlink" title="ResourceUpdater"></a>ResourceUpdater</h2><p>在资源加载篇, 我们简单提了一嘴资源更新, 这篇就来详细讲解其替身使者 <code>ResourceUpdater</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset/img/GameFramework-6.4.jpg" alt="GameFramework-6.4"></p>
<p><code>ApplyInfo</code>  与 <code>UpdateInfo</code> 在很大程度上是相似的, 其核心是围绕资源展开的, 而二者共同的成员变量就是 <code>ResourceInfo</code> 的成员变量, 感觉其中的关系可以好好理一下. 不过这个暂且先放一边, 通过观察 <code>ResourceUpdater</code> 的成员可以知道其核心功能就两个: Apply 和 Update.</p>
<h3 id="UpdateResource"><a href="#UpdateResource" class="headerlink" title="UpdateResource"></a>UpdateResource</h3><h4 id="以资源组为单位进行更新"><a href="#以资源组为单位进行更新" class="headerlink" title="以资源组为单位进行更新"></a>以资源组为单位进行更新</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 更新指定资源组的资源。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;resourceGroup&quot;&gt;</span>要更新的资源组。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateResources</span>(<span class="params">ResourceGroup resourceGroup</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_DownloadManager == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;You must set download manager first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_CheckResourcesComplete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;You must check resources complete first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_ApplyingResourcePackStream != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;There is already a resource pack &#x27;&#123;0&#125;&#x27; being applied.&quot;</span>, m_ApplyingResourcePackPath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_UpdatingResourceGroup != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;There is already a resource group &#x27;&#123;0&#125;&#x27; being updated.&quot;</span>, m_UpdatingResourceGroup.Name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(resourceGroup.Name))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 资源组名为空就把候选列表全都加入待更新列表</span></span><br><span class="line">        <span class="keyword">foreach</span> (KeyValuePair&lt;ResourceName, UpdateInfo&gt; updateInfo <span class="keyword">in</span> m_UpdateCandidateInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            m_UpdateWaitingInfo.Add(updateInfo.Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 资源组名不为空就获取到资源组里所有资源的资源名</span></span><br><span class="line">        resourceGroup.InternalGetResourceNames(m_CachedResourceNames);</span><br><span class="line">        <span class="keyword">foreach</span> (ResourceName resourceName <span class="keyword">in</span> m_CachedResourceNames)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在资源组同时在候选列表的所有资源加载待更新列表</span></span><br><span class="line">            UpdateInfo updateInfo = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_UpdateCandidateInfo.TryGetValue(resourceName, <span class="keyword">out</span> updateInfo))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 添加到待更新列表, 这个会留在Update函数中进行处理</span></span><br><span class="line">            m_UpdateWaitingInfo.Add(updateInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空留着备用</span></span><br><span class="line">        m_CachedResourceNames.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记正在更新的资源组</span></span><br><span class="line">    m_UpdatingResourceGroup = resourceGroup;</span><br><span class="line">    m_FailureFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 资源更新器轮询。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elapseSeconds&quot;&gt;</span>逻辑流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;realElapseSeconds&quot;&gt;</span>真实流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ApplyingResourcePackStream != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (m_ApplyWaitingInfo.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ApplyInfo applyInfo = m_ApplyWaitingInfo.Dequeue();</span><br><span class="line">            <span class="keyword">if</span> (ApplyResource(applyInfo))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Array.Clear(m_CachedBytes, <span class="number">0</span>, CachedBytesLength);</span><br><span class="line">        <span class="built_in">string</span> resourcePackPath = m_ApplyingResourcePackPath;</span><br><span class="line">        m_ApplyingResourcePackPath = <span class="literal">null</span>;</span><br><span class="line">        m_ApplyingResourcePackStream.Dispose();</span><br><span class="line">        m_ApplyingResourcePackStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ResourceApplyComplete != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ResourceApplyComplete(resourcePackPath, !m_FailureFlag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_UpdateCandidateInfo.Count &lt;= <span class="number">0</span> &amp;&amp; ResourceUpdateAllComplete != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ResourceUpdateAllComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当待更新资源数量大于0时</span></span><br><span class="line">    <span class="keyword">if</span> (m_UpdateWaitingInfo.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取到在没有下载任务情况下的闲置下载代理器的数量</span></span><br><span class="line">        <span class="built_in">int</span> freeCount = m_DownloadManager.FreeAgentCount - m_DownloadManager.WaitingTaskCount;</span><br><span class="line">        <span class="keyword">if</span> (freeCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对待更新列表进行更新处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; m_UpdateWaitingInfo.Count &amp;&amp; count &lt; freeCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (DownloadResource(m_UpdateWaitingInfo[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="以资源为单位进行更新"><a href="#以资源为单位进行更新" class="headerlink" title="以资源为单位进行更新"></a>以资源为单位进行更新</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 更新指定资源。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;resourceName&quot;&gt;</span>要更新的资源名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateResource</span>(<span class="params">ResourceName resourceName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_DownloadManager == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;You must set download manager first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_CheckResourcesComplete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;You must check resources complete first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_ApplyingResourcePackStream != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;There is already a resource pack &#x27;&#123;0&#125;&#x27; being applied.&quot;</span>, m_ApplyingResourcePackPath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UpdateInfo updateInfo = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 倘若在更新的资源在候选更新列表且不处于正在更新的列表中, 就下载资源</span></span><br><span class="line">    <span class="keyword">if</span> (m_UpdateCandidateInfo.TryGetValue(resourceName, <span class="keyword">out</span> updateInfo) &amp;&amp; m_UpdateWaitingInfoWhilePlaying.Add(updateInfo))</span><br><span class="line">    &#123;</span><br><span class="line">        DownloadResource(updateInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种更新方式都离不开 <code>DownloadResource</code>, 看看其代码</p>
<h4 id="DownloadResource"><a href="#DownloadResource" class="headerlink" title="DownloadResource"></a>DownloadResource</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">DownloadResource</span>(<span class="params">UpdateInfo updateInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updateInfo.Downloading)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 标记正在下载</span></span><br><span class="line">    updateInfo.Downloading = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 使用三目运算符得到一个字符串, 字符串会用来拼凑文件地址, 这个信息是在打包的时候确定的.(考点来了)</span></span><br><span class="line">    <span class="built_in">string</span> resourceFullNameWithCrc32 = updateInfo.ResourceName.Variant != <span class="literal">null</span> ? Utility.Text.Format(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;.&#123;2:x8&#125;.&#123;3&#125;&quot;</span>, updateInfo.ResourceName.Name, updateInfo.ResourceName.Variant, updateInfo.HashCode, DefaultExtension) : Utility.Text.Format(<span class="string">&quot;&#123;0&#125;.&#123;1:x8&#125;.&#123;2&#125;&quot;</span>, updateInfo.ResourceName.Name, updateInfo.HashCode, DefaultExtension);</span><br><span class="line">    <span class="comment">// 执行下载步骤</span></span><br><span class="line">    m_DownloadManager.AddDownload(updateInfo.ResourcePath, Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_UpdatePrefixUri, resourceFullNameWithCrc32)), updateInfo);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心就是依赖 <code>DownloadManager</code> 执行资源下载到本地的步骤. 当 <code>Resource</code> 下载完成后触发 <code>OnDownloadSuccess</code> 回调. 对其进行资源验证后确定是否保留, 原样保留还是写入 <code>FileSystem</code>. 当所有资源下载完成的时候重新生成 GameFrameworkList.dat.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>ResourceUpdater</code> 的重要信息都已经讲解完毕了, 没有讲到的 <code>ResourceGroup</code> 在这里只是过客. 既不由此生, 也不为其用, 本小姐暂且放过它.</p>
<p>整理一下目前得到的信息.</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>m_UpdateCandidateInfo</th>
<th>m_UpdateWaitingInfo</th>
<th>m_UpdateWaitingInfoWhilePlaying</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>Dictionary</td>
<td>List</td>
<td>HashSet</td>
</tr>
<tr>
<td>Add调用处</td>
<td>ResourceManager.OnCheckerResourceNeedUpdate</td>
<td>UpdateResource(ResourceGroup)</td>
<td>UpdateResource(ResourceName)</td>
</tr>
<tr>
<td>Remove调用处</td>
<td>OnDownloadSuccess<br />ApplyResource</td>
<td>OnDownloadSuccess<br />OnDownloadFailure</td>
<td>OnDownloadSuccess<br />OnDownloadFailure</td>
</tr>
<tr>
<td>资源下载失败时的处理</td>
<td>不处理</td>
<td>移除</td>
<td>重试后移除</td>
</tr>
</tbody></table>
<p>这三个虽然都有点等待队列的意思, 但其存储信息的生命周期有着微妙的差别. <code>m_UpdateCandidateInfo</code> 的开始时间早于另外两个, 结束时间也晚于另外两个.</p>
<h3 id="ApplyResources"><a href="#ApplyResources" class="headerlink" title="ApplyResources"></a>ApplyResources</h3><p><code>ApplyResource</code> 搞了一大堆事, 其最终目的是把下载下来的资源在 <code>ResourceManager.m_ResourceInfos</code> 中设定为准备就绪.</p>
<p>流程如下</p>
<p>1.<br>2.<br>3. </p>
<blockquote>
<p>流程个锤子! 这个除了没做下载以外和 <code>UpdateResource</code> 基本一模一样, 甚至完全一样. 我有九九成的把握这是烟雾弹, 这里让我浪费好多时间, 啊啊啊啊啊!!!!</p>
<p>这个很有可能原意是要写在 <code>OnDownloadSuccess</code> 中的</p>
</blockquote>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>为什么在 <code>UpdateResource(ResourceGroup)</code> 的模式下需要检查下载代理是否空闲而 <code>UpdateResource(ResourceName)</code> 的时候不需要呢?</p>
<p>原因未知, 请大佬指教.</p>
</li>
<li><p><code>ResourceUpdater</code> 里 <code>OnDownloadUpdate</code> 的 <code>m_DownloadManager.RemoveDownload(e.SerialId);</code> 为何将下载任务的判错挪到了 <code>ResourceUpdater</code> 里呢? </p>
<p>因为这些信息在每一次下载中不一定都能获取到, 不能写在通用的下载器中.</p>
</li>
<li><p><code>ResourceUpdater</code> 中 <code>ApplyResource</code> 无需设为公共的, 这个是针对更新的数据写入到资源数据中心使用的. </p>
</li>
<li><p><code>ResourceUpdater</code> 中甚至不需要 <code>ApplyResource </code>, 因为完全用不上啊. 资源初始化被 <code>ResourceChecker</code> 做了, AB 包的下载被 <code>UpdateResource</code> 做了.</p>
</li>
</ol>
<h1 id="知识点图"><a href="#知识点图" class="headerlink" title="知识点图"></a>知识点图</h1><p>看这个源码真的学到了好多, 从完全不懂编辑器开发和服务器搭建还有热更新的人变成了这三个都能小谈一会儿的人了, 还深知了完整一套的资源方案. 虽然学到了很多, 但我还是觉得亏了, 因为切入口不对, 时间上花费的太多了.</p>
<p>这期知识点图就不摆了, 上面摆的够用了.</p>
<p>还让我摆? 满足你!</p>
<p><img src="https://img2.baidu.com/it/u=3161035618,812945627&fm=253&fmt=auto&app=138&f=JPEG?w=600&h=419"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Game-Framework/">Game Framework</a></div><div class="post_share"><div class="social-share" data-image="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/DotNetDataAnalysis/"><img class="next-cover" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">.Net 平台的数据分析解决方案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/GameFramework-1/" title="Game Framework - 生命周期"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-18</div><div class="title">Game Framework - 生命周期</div></div></a></div><div><a href="/GameFramework-0/" title="Game Framework - 概述"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">Game Framework - 概述</div></div></a></div><div><a href="/GameFramework-3/" title="Game Framework - 事件中心"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">Game Framework - 事件中心</div></div></a></div><div><a href="/GameFramework-2/" title="Game Framework - 内存管理"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Game Framework - 内存管理</div></div></a></div><div><a href="/GameFramework-4/" title="Game Framework - 任务异步"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-08</div><div class="title">Game Framework - 任务异步</div></div></a></div><div><a href="/GameFramework-5/" title="Game Framework - Web请求与下载"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">Game Framework - Web请求与下载</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/yuyuko_avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">幽幽墨染，樱树花开</div><div class="author-info__description">愿于春日樱下死, 阴历二月满月时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuyuko-C"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuyuko-C" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1061439585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">头像是我老婆, 养不起的那种.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">资源流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">资源打包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceCollection"><span class="toc-number">2.1.</span> <span class="toc-text">ResourceCollection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Asset-%E4%B8%8E-Resource"><span class="toc-number">2.1.1.</span> <span class="toc-text">Asset 与 Resource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceBuilderController"><span class="toc-number">2.2.</span> <span class="toc-text">ResourceBuilderController</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalVersionList%E3%80%81UpdatableVersionList-%E5%92%8C-PackageVersionList"><span class="toc-number">2.2.1.</span> <span class="toc-text">LocalVersionList、UpdatableVersionList 和 PackageVersionList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PackageVersionList-%E5%92%8C-UpdatableVersionList"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">PackageVersionList 和 UpdatableVersionList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalVersionList%E5%92%8CUpdatableVersionList"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">LocalVersionList和UpdatableVersionList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AssetData-%E4%B8%8E-ResourceData"><span class="toc-number">2.2.2.</span> <span class="toc-text">AssetData 与 ResourceData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VersionListData"><span class="toc-number">2.2.3.</span> <span class="toc-text">VersionListData</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceAnalyzerController"><span class="toc-number">2.3.</span> <span class="toc-text">ResourceAnalyzerController</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DependecyData"><span class="toc-number">2.3.1.</span> <span class="toc-text">DependecyData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">循环依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceEditorController"><span class="toc-number">2.4.</span> <span class="toc-text">ResourceEditorController</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">资源初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">资源加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceName"><span class="toc-number">4.1.1.</span> <span class="toc-text">ResourceName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AssetInfo-%E4%B8%8E-ResourceInfo"><span class="toc-number">4.1.2.</span> <span class="toc-text">AssetInfo 与 ResourceInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AssetObject-%E5%92%8C-ResourceObject"><span class="toc-number">4.1.3.</span> <span class="toc-text">AssetObject 和 ResourceObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-LoadResourceTaskBase"><span class="toc-number">4.2.</span> <span class="toc-text">ResourceLoader.LoadResourceTaskBase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-LoadResourceAgent"><span class="toc-number">4.3.</span> <span class="toc-text">ResourceLoader.LoadResourceAgent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OnResourceObjectReady-%E4%B8%8E-OnAssetObjectReady"><span class="toc-number">4.3.1.</span> <span class="toc-text">OnResourceObjectReady 与 OnAssetObjectReady</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start"><span class="toc-number">4.3.2.</span> <span class="toc-text">Start</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-LoadAsset"><span class="toc-number">4.4.</span> <span class="toc-text">ResourceLoader.LoadAsset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CheckAsset"><span class="toc-number">4.4.1.</span> <span class="toc-text">CheckAsset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadDependencyAsset"><span class="toc-number">4.4.2.</span> <span class="toc-text">LoadDependencyAsset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-LoadScene"><span class="toc-number">4.5.</span> <span class="toc-text">ResourceLoader.LoadScene</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-LoadBinary"><span class="toc-number">4.6.</span> <span class="toc-text">ResourceLoader.LoadBinary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">4.7.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"><span class="toc-number">5.</span> <span class="toc-text">资源更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#VersionListProcessor"><span class="toc-number">5.1.</span> <span class="toc-text">VersionListProcessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceVerifier"><span class="toc-number">5.2.</span> <span class="toc-text">ResourceVerifier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceChecker"><span class="toc-number">5.3.</span> <span class="toc-text">ResourceChecker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceUpdater"><span class="toc-number">5.4.</span> <span class="toc-text">ResourceUpdater</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UpdateResource"><span class="toc-number">5.4.1.</span> <span class="toc-text">UpdateResource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E8%B5%84%E6%BA%90%E7%BB%84%E4%B8%BA%E5%8D%95%E4%BD%8D%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">以资源组为单位进行更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E8%B5%84%E6%BA%90%E4%B8%BA%E5%8D%95%E4%BD%8D%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">以资源为单位进行更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DownloadResource"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">DownloadResource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.4.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplyResources"><span class="toc-number">5.4.2.</span> <span class="toc-text">ApplyResources</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2"><span class="toc-number">5.5.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">知识点图</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-6/" title="Game Framework - 资源管理"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - 资源管理"/></a><div class="content"><a class="title" href="/GameFramework-6/" title="Game Framework - 资源管理">Game Framework - 资源管理</a><time datetime="2023-03-08T18:07:13.000Z" title="发表于 2023-03-09 02:07:13">2023-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DotNetDataAnalysis/" title=".Net 平台的数据分析解决方案"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=".Net 平台的数据分析解决方案"/></a><div class="content"><a class="title" href="/DotNetDataAnalysis/" title=".Net 平台的数据分析解决方案">.Net 平台的数据分析解决方案</a><time datetime="2023-03-01T15:12:57.000Z" title="发表于 2023-03-01 23:12:57">2023-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/VSCodeShortcutKey/" title="Visual Studio Code 快捷键大全"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Visual Studio Code 快捷键大全"/></a><div class="content"><a class="title" href="/VSCodeShortcutKey/" title="Visual Studio Code 快捷键大全">Visual Studio Code 快捷键大全</a><time datetime="2023-02-27T02:05:27.000Z" title="发表于 2023-02-27 10:05:27">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-5/" title="Game Framework - Web请求与下载"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - Web请求与下载"/></a><div class="content"><a class="title" href="/GameFramework-5/" title="Game Framework - Web请求与下载">Game Framework - Web请求与下载</a><time datetime="2023-01-30T12:10:42.000Z" title="发表于 2023-01-30 20:10:42">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-4/" title="Game Framework - 任务异步"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - 任务异步"/></a><div class="content"><a class="title" href="/GameFramework-4/" title="Game Framework - 任务异步">Game Framework - 任务异步</a><time datetime="2022-12-08T03:57:55.000Z" title="发表于 2022-12-08 11:57:55">2022-12-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 幽幽墨染，樱树花开</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>