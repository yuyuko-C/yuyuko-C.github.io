<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Game Framework - 事件中心 | 雪の亡霊</title><meta name="author" content="西行寺幽幽子"><meta name="copyright" content="西行寺幽幽子"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#7B73BE"><meta name="description" content="事件中心的由来游戏项目里经常会有这样的需求: 当XXX时就YYY.  比如当玩家受到攻击时给玩家增加护甲, 我们自然可以给出如下写法: 123456789101112&#x2F;&#x2F; 受到伤害函数public void GetAttack()&amp;#123;    &#x2F;&#x2F; 扣血    HP--;    &#x2F;&#x2F; 死亡判定    if(HP&lt;&#x3D;0)        Dead();        &#x2F;&#x2F; 增加护甲">
<meta property="og:type" content="article">
<meta property="og:title" content="Game Framework - 事件中心">
<meta property="og:url" content="https://yuyuko-c.github.io/GameFramework-3/index.html">
<meta property="og:site_name" content="雪の亡霊">
<meta property="og:description" content="事件中心的由来游戏项目里经常会有这样的需求: 当XXX时就YYY.  比如当玩家受到攻击时给玩家增加护甲, 我们自然可以给出如下写法: 123456789101112&#x2F;&#x2F; 受到伤害函数public void GetAttack()&amp;#123;    &#x2F;&#x2F; 扣血    HP--;    &#x2F;&#x2F; 死亡判定    if(HP&lt;&#x3D;0)        Dead();        &#x2F;&#x2F; 增加护甲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b">
<meta property="article:published_time" content="2022-11-25T01:59:35.000Z">
<meta property="article:modified_time" content="2023-03-26T07:38:46.971Z">
<meta property="article:author" content="西行寺幽幽子">
<meta property="article:tag" content="Game Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuyuko-c.github.io/GameFramework-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Game Framework - 事件中心',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 15:38:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#7B73BE')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#7B73BE')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/yuyuko_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雪の亡霊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Game Framework - 事件中心</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-25T01:59:35.000Z" title="发表于 2022-11-25 09:59:35">2022-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T07:38:46.971Z" title="更新于 2023-03-26 15:38:46">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/Game-Framework/">Game Framework</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Game Framework - 事件中心"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="事件中心的由来"><a href="#事件中心的由来" class="headerlink" title="事件中心的由来"></a>事件中心的由来</h1><p>游戏项目里经常会有这样的需求: 当XXX时就YYY. </p>
<p>比如当玩家受到攻击时给玩家增加护甲, 我们自然可以给出如下写法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 受到伤害函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAttack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 扣血</span></span><br><span class="line">    HP--;</span><br><span class="line">    <span class="comment">// 死亡判定</span></span><br><span class="line">    <span class="keyword">if</span>(HP&lt;=<span class="number">0</span>)</span><br><span class="line">        Dead();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加护甲</span></span><br><span class="line">    AddAmor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果条件更加复杂, 甚至是其他类的逻辑, 这里就会变成垃圾场. 一个简单的受到伤害的函数变得臃肿不堪, 并且一旦版本更新维护, 这里的就是 bug 的孵化基地. </p>
<p>比如, 如果要增加攻击者的移动速度呢? 这个函数甚至没法实现, 因为获取不到攻击的人. 我们需要给这个函数加参数才行.</p>
<p>或许你还没有感觉, 但是如果现在条件不仅仅只有受到伤害时, 还有造成伤害时, 释放技能时, 购买物品时, 造成控制时, 被击飞时 等诸多触发条件, 触发条件里还有筛选条件, 且触发效果多种多样. 此时要你去增加&#x2F;删除&#x2F;修改某个效果, 是不是就有感觉了?</p>
<p>那么有没有一种办法能让这里变得简洁一点呢? 当然有</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 受到伤害函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAttack</span>(<span class="params">Unit attacker</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 扣血</span></span><br><span class="line">    HP--;</span><br><span class="line">    <span class="comment">// 死亡判定</span></span><br><span class="line">    <span class="keyword">if</span>(HP&lt;=<span class="number">0</span>)</span><br><span class="line">        Dead();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有逻辑转移出这个地方, GetAttack就不用修改</span></span><br><span class="line">    WhenGetAttack(attacker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样依然治标不治本. 只是垃圾场换到了别的函数而已. 而且把其他东西的效果写到自己的脚本逻辑里是不是有点不太正常? 于是我们需要在一个第三方作为中转站, 将各个事件发生的消息收集起来, 需要监听本事件的告诉这个第三方我需要接受到这个事件做这件事. 这就需要我们今天的主角——事件中心.</p>
<h1 id="事件中心"><a href="#事件中心" class="headerlink" title="事件中心"></a>事件中心</h1><p>事件中心就好像是新闻电视台, 而电视台获取到新闻就必须有记者, 记者就是事件中心埋在事件发布处的语句. 记者探测事件, 电视台分发事件, 所有观看电视台的观众都会接收到这个事件. 再也不需要观众们互相告知有没有此事件发生了. </p>
<p>观众想要接收到事件就必须先把电视切换到新闻联播, 不然就会错过事件. 这一行为被称为订阅. 让分发中心知道你对这个内容感兴趣, 当事件发生的时候就会通知你. 同理, 你也可以换台取消订阅.</p>
<p>使用事件中心后上面的代码只需要修改为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 受到伤害函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAttack</span>(<span class="params">Unit attacker</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 扣血</span></span><br><span class="line">    HP--;</span><br><span class="line">    <span class="comment">// 死亡判定</span></span><br><span class="line">    <span class="keyword">if</span>(HP&lt;=<span class="number">0</span>)</span><br><span class="line">        Dead();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记者告诉电视台有人受伤了,电视台立刻把这件事发布了出去</span></span><br><span class="line">    Event.EventNotify(<span class="string">&quot;GetAttack&quot;</span>,attacker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等电视台将事件播报出去的时候, 无论是逃跑还是反击还是围观, 观众都可以根据自己的行为逻辑进行调整.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单位类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Unit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Unit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Event.ListenEvent(<span class="string">&quot;GetAttack&quot;</span>,GetAttackCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个函数, 订阅被攻击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetAttackCallback</span>(<span class="params">Unit attacker</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 民众</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span>: <span class="title">Unit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetAttackCallback</span>(<span class="params">Unit attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;有人被攻击了, 我去围观&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Policeman</span>: <span class="title">Unit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetAttackCallback</span>(<span class="params">Unit attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;有人被攻击了, 我去帮忙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们很快发现一个问题, 谁被攻击了? 不知道, 只知道攻击者是谁. 在哪里被攻击的? 不知道. 那打出了多少伤害? 不知道. 怎么打的? 不知道.</p>
<p>事件中心虽然能避免函数变垃圾场, 但设计的不好依然会出现一堆问题. 那么就让我们来看看 GameFramework 的事件中心吧.</p>
<h1 id="GameFramework-中的事件中心"><a href="#GameFramework-中的事件中心" class="headerlink" title="GameFramework 中的事件中心"></a>GameFramework 中的事件中心</h1><p>GF 中的事件中心由三部分组成. </p>
<ul>
<li>BaseEventArgs : 所有事件的基类, 提供一个事件ID用于辨识事件.</li>
<li>Event : 改名为 EventNode 更好. 用来存储 事件发送者 与 事件信息</li>
<li>EventPool : 事件池, 起着事件中心的作用, 用于事件发布.</li>
</ul>
<h2 id="BaseEventArgs"><a href="#BaseEventArgs" class="headerlink" title="BaseEventArgs"></a>BaseEventArgs</h2><p>BaseEventArgs 继承自 GameFrameworkEventArgs, 而 GameFrameworkEventArgs 继承自 System.EventArgs. 直到 BaseEventArgs 才给出一个抽象方法 Id. 这个 Id 获取到的就是事件的唯一标识, 返回的是子类的静态成员变量 EventID, 其值是子类Type的 hashcode.</p>
<p>至于 GameFrameworkEventArgs 仅是为了让其继承 IReference 接口, 为可回收做准备.</p>
<p>为什么要继承 System.EventArgs 呢? 我们都知道事件中心的事件是由我们自己定义的, 并且 System.EventArgs 没有任何实际作用, 只是在 System 命名空间下的类而已. </p>
<p>然后我们发现 EventPool 中使用的 System.EventHandler<T> 是一个委托, 其事件参数正是之前用到的 System.EventArgs. </p>
<p>这两个东西有什么用呢? —— 因为相信E大不会做无用的设计, 我曾天真的因为是用来承接系统事件的, 但实在想不到该怎么承接系统事件, 所以对这个答案一直保持怀疑. <strong>真实答案是继承没用</strong>. 不继承这两个东西, 事件中心依然正常运行.</p>
<p>那为什么要继承呢? 这其实是一个规范与约定, 与系统库保持一样的风格. 遵守该规范可以让其他人更清晰的知道这是你定义的事件. .Net 中大量使用了这对组合进行事件的定义与使用. 如计时器事件, 鼠标键盘事件, 按钮点击事件. (又学到了, 原来有这个约定存在)  <a target="_blank" rel="noopener" href="http://t.zoukankan.com/porter-p-5895132.html">c# 事件为何要继承EventArgs - 走看看 (zoukankan.com)</a></p>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>Event 是处于 EventPool 类中的私有类, 其作用是临时存储 事件发送者 和 事件. 同样继承 IReference 接口, 为可回收做准备. 每当事件发生时就会使用 Event 保存两者的信息. </p>
<p>这个类只在线程安全的事件触发流程中使用.</p>
<h2 id="EventPool"><a href="#EventPool" class="headerlink" title="EventPool"></a>EventPool</h2><p>作为事件中心, 除了之前讲的一样需要事件探测和事件发布外, 还需要订阅事件与取消订阅事件. 因为事件仅需要发送给关注对象, 不需要广播给所有对象. 更何况如果函数所属的对象已经销毁了是需要将其回收的, 不能继续触发. 因此 EventPool 定义了 Subscribe &#x2F; Unsubscribe 和 Fire 方法. 分别是订阅, 取消订阅 和 事件发布.</p>
<h1 id="EventPool-详解"><a href="#EventPool-详解" class="headerlink" title="EventPool 详解"></a>EventPool 详解</h1><h2 id="EventPool-为何不唯一"><a href="#EventPool-为何不唯一" class="headerlink" title="EventPool 为何不唯一"></a>EventPool 为何不唯一</h2><p>我们可以看到 EventPool 是一个泛型的非静态类. 正常来说作为事件中心本该是唯一的, 不应该会采用这种设计, 这是怎么回事呢? 我们来逐一分析:</p>
<ul>
<li><p>能是静态类吗?</p>
<p>根据需求来, 如果需要多个 EventPool 就不能是静态类.</p>
<p>E大通过 EventPoolMode 参数希望事件池自己对此条件进行检查, 如果事件池在使用中不符合要求则会抛出异常, 这就注定了必须要有多个池子, 不然这个参数将毫无意义. 如果不需要的此种条件检查可以将之声明为静态类.</p>
</li>
<li><p>能取消泛型吗? </p>
<p>根据需求来, 这里的泛型的作用不是很显眼, 单纯是为了限制事件类型. 如果不需要限制类型可以取消.</p>
<p>这里涉及到一个访问权限的问题.  但在讲解前我们必须知道一些补充知识 :</p>
<ol>
<li>EventManager 只是 EventPool 在泛型作为 GameEventArgs 的套壳.</li>
<li>GameEventArgs 继承自 BaseEventArgs, Packet 也继承自 BaseEventArgs, 而这两个都是抽象空继承.</li>
<li>只有 BaseEventArgs 以及其子类才能用在 EventPool , 因为 BaseEventArgs 这一步才有事件 ID. 所以如果取消泛型, EventPool 里存的只能是 BaseEventArgs.</li>
</ol>
<p>我们注意到 BaseEventArgs 的访问权限为 public, 如果没有此泛型, 用户可以将自己定义的 BaseEventArgs 的子类甚至 Packet 传进 EventManager. 而事实上 EventManager 的事件基类是 GameEventArgs, 杜绝了 Packet 和 自定义子类被传进来.又因 EventPool 作为 internal 的访问类型, 所以绝不会再有其他类型的事件池出现了.</p>
</li>
</ul>
<h2 id="EventPool-的运作机制"><a href="#EventPool-的运作机制" class="headerlink" title="EventPool 的运作机制"></a>EventPool 的运作机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事件中心的运作核心: 订阅&#x2F;取消订阅&#x2F;发布事件, 全都围着着一个成员变量展开 <code>GameFrameworkMultiDictionary&lt;int, EventHandler&lt;T&gt;&gt; m_EventHandlers</code></p>
<p>GameFrameworkMultiDictionary 是E大自定义的类, 其作用与 <code>Dictionary&lt;int, LinkedList&lt;EventHandler&lt;T&gt;&gt;&gt;</code> 相仿, 是一键对多值的设定. 其 key 则为 BaseEventArgs 的事件ID, 其 value 则为所有订阅其事件的委托函数的链表.</p>
<p>当一个事件触发时, 通过其事件ID获得其委托链表并逐一执行即实现了响应事件, 订阅与取消事件则是在相应的事件委托链表中做增减.</p>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><p>事件触发在 EventPool 有两种路线, 线程安全与非线程安全. 其对应函数分别是 Fire 和 FireNow.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抛出事件，这个操作是线程安全的，即使不在主线程中抛出，也可保证在主线程中回调事件处理函数，但事件会在抛出后的下一帧分发。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event eventNode = Event.Create(sender, e);</span><br><span class="line">    <span class="keyword">lock</span> (m_Events)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Events.Enqueue(eventNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抛出事件立即模式，这个操作不是线程安全的，事件会立刻分发。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireNow</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HandleEvent(sender, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FireNow-函数"><a href="#FireNow-函数" class="headerlink" title="FireNow 函数"></a>FireNow 函数</h3><p>看着注释我陷入了沉思, 为什么要留一个线程不安全的函数呢? 明知道线程不安全为什么不改成线程安全? 线程安全又可以立刻分发的需求要怎么办?</p>
<p>我这里其实陷入了一个伪需求陷阱. 多线程处理的都是耗时操作, 通常都需要多帧才能处理完毕, 这种方式分发的事件是不会纠结在这一帧还是下一帧触发的, 因为使用多线程本身就表明了对不及时的容忍. 至于为什么不将其改成线程安全, 是因为获取锁, 释放锁, 线程上下文的切换都是耗性能的, 某些情况下损耗甚至非常大, 没必要在已有 Fire 的情况下将 FireNow 也加锁降低性能.</p>
<h3 id="Fire-函数"><a href="#Fire-函数" class="headerlink" title="Fire 函数"></a>Fire 函数</h3><p>可以看到使用 Fire 函数会先生成一个节点存起来然后在 Update 函数中调用, 为什么不简单一点写成这样呢?</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">lock</span> (m_Events)</span><br><span class="line">    &#123;</span><br><span class="line">        HandleEvent(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个原因:</p>
<ol>
<li>HandleEvent 函数是一个比较”重”的函数, 相比于 <code>m_Events.Enqueue(eventNode);</code> 需要花费更多时间执行, 因而锁的时间会更久. 恰好 Fire 又是一个用于多线程的函数, 因此会在此多次而长时间的遇到线程同步, 从而大大影响执行效率.</li>
<li>虽然 EventPool 里有 Update 和 Shutdown 函数, 但其本身并不是游戏模块 (并不继承自 GameFrameworkModule). 这就说明 EventPool 的轮询顺序由包裹它的游戏模块决定. 我们在第一章提到了游戏模块的优先级决定其轮询顺序, 这里就是为了保证各个游戏模块的执行顺序不乱套存在的. 如果在 Fire 中直接进行事件处理, 各个模块的处理顺序将会被彻底打乱.</li>
</ol>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>Fire 函数为了线程安全加锁想必都不会怀疑, 但不知道你是否对 Update 中的锁产生过怀疑.</p>
<p>这个 Update 是被游戏模块调用的, 游戏模块是全局唯一的, 游戏模块是在主线程中调用的, Update 完全不会被多线程调用, Update 中的锁存在为何? </p>
<p>其实这个锁是防止 Fire 在添加函数时 Update 的 while 循环未完整执行一轮, 虽然 Update 本身调用安全, 但其他线程的 Fire 对 Update 还是具有侵入性的. 所以线程同步需要保持平等的原则, 不能一边设防一边不设防.</p>
<h3 id="事件中取消订阅"><a href="#事件中取消订阅" class="headerlink" title="事件中取消订阅"></a>事件中取消订阅</h3><p>一般使用取消订阅不会出现问题,  一旦在事件中取消订阅, 就会出现问题. 这个行为会在取消下一个 EventHandler 的时候产生链表断链. </p>
<p><strong>下面的代码从 HandleEvent 函数开始跟, 详情请看我在代码中的注释. 这部分比较烧脑, 请务必耐心.</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 取消订阅事件处理函数。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要取消订阅的事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params"><span class="built_in">int</span> id, EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event handler is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将下一个节点保存至原节点的位置</span></span><br><span class="line">    <span class="comment">// 此时 Count&gt;0 代表正在处理至少一个事件,所以进入这里就代表是在事件中取消订阅(和多线程没关系,多线程的问题被线程安全解决了)</span></span><br><span class="line">    <span class="comment">// 所以进入这里就代表是在事件中取消订阅, 接下来就对链表进行重链接.</span></span><br><span class="line">    <span class="keyword">if</span> (m_CachedNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历每个取消订阅的事件的节点</span></span><br><span class="line">        <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_CachedNodes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓存节点可能是null</span></span><br><span class="line">            <span class="comment">// 如果缓存节点不是null, 就看缓存节点的EventHanler是否是要取消的, 如果是获取到它的下一个</span></span><br><span class="line">            <span class="keyword">if</span> (cachedNode.Value != <span class="literal">null</span> &amp;&amp; cachedNode.Value.Value == handler)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这里是在移除前, 能获取到下一个节点, 移除后链表会将其的Next指针置空</span></span><br><span class="line">                m_TempNodes.Add(cachedNode.Key, cachedNode.Value.Next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新把每个事件的下一个节点指向到即将被取消节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (m_TempNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_TempNodes)</span><br><span class="line">            &#123;</span><br><span class="line">                m_CachedNodes[cachedNode.Key] = cachedNode.Value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_TempNodes.Clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来就是正式取消节点, 然后此函数结束后会回到HandleEvent函数的循环中</span></span><br><span class="line">        <span class="comment">// 因为改写了m_CachedNodes, 下一个执行的就不会是当前要取消的HandlerNode了, 也就不会链表断连了. </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表当移除节点的时候不是单纯的跨节点指向,会把当前节点的上一个和下一个节点都置空</span></span><br><span class="line">    <span class="keyword">if</span> (!m_EventHandlers.Remove(id, handler))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not exists specified handler.&quot;</span>, id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 处理事件结点。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> noHandlerException = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 尝试获取事件对应的所有EventHandler</span></span><br><span class="line">    GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt;);</span><br><span class="line">    <span class="keyword">if</span> (m_EventHandlers.TryGetValue(e.Id, <span class="keyword">out</span> range))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历所有handler</span></span><br><span class="line">        LinkedListNode&lt;EventHandler&lt;T&gt;&gt; current = range.First;</span><br><span class="line">        <span class="comment">// 如果有下一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current != range.Terminal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓存下一个委托节点,没有就是Null;</span></span><br><span class="line">            m_CachedNodes[e] = current.Next != range.Terminal ? current.Next : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 执行当前委托节点的值,也就是EventHandler.</span></span><br><span class="line">            <span class="comment">// 在此函数中会执行UnSubscribe</span></span><br><span class="line">            current.Value(sender, e);</span><br><span class="line">            <span class="comment">// 使当前的委托节点变成缓存的节点</span></span><br><span class="line">            current = m_CachedNodes[e];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除缓存的handler, 理论上来说此时字典应该是空的了.</span></span><br><span class="line">        m_CachedNodes.Remove(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_DefaultHandler != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有就采用默认的Handler</span></span><br><span class="line">        m_DefaultHandler(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((m_EventPoolMode &amp; EventPoolMode.AllowNoHandler) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记需要报错的信息</span></span><br><span class="line">        <span class="comment">// - 因为抛出异常后不能执行代码, 所以需要做标记, 先引用池回收再抛出异常.</span></span><br><span class="line">        noHandlerException = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理完成后回收事件信息</span></span><br><span class="line">    ReferencePool.Release(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常. 为什么抛出异常还必须要先回收</span></span><br><span class="line">    <span class="comment">// - Unity的异常处理机制让抛出异常不会停止程序, 程序会继续运行</span></span><br><span class="line">    <span class="keyword">if</span> (noHandlerException)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not allow no handler.&quot;</span>, e.Id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还是不理解, 参见烟雨大佬的讲解视频</p>

<iframe height="400" width="600" src="//player.bilibili.com/player.html?aid=96893545&bvid=BV177411Z7eP&cid=165424889&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h3 id="其他成员变量"><a href="#其他成员变量" class="headerlink" title="其他成员变量"></a>其他成员变量</h3><p>m_EventPoolMode: 添加事件委托时根据枚举值不同对池子中的事件委托进行条件检查, 不符合则会抛出异常</p>
<p>m_DefaultHandler: 默认的事件处理委托, 作为备选委托, 如果没有委托处理事件则会使用此委托</p>
<h1 id="延伸-事件中心的几种模式"><a href="#延伸-事件中心的几种模式" class="headerlink" title="延伸: 事件中心的几种模式"></a>延伸: 事件中心的几种模式</h1><p>根据我的见闻, 事件中心可以按以下四个维度进行分类. 个人比较喜欢中心式唯一参数的, GF 也是这么做的. 虽然有点区别, 是设立了两个中心: 本地事件与网络消息.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>事件中心数量</td>
<td>分布式&#x2F;中心式</td>
</tr>
<tr>
<td>事件类型与事件参数的关系</td>
<td>分离&#x2F;统一</td>
</tr>
<tr>
<td>事件参数的数量</td>
<td>多参数&#x2F;唯一参数</td>
</tr>
<tr>
<td>事件参数的类型</td>
<td>指定参数类型&#x2F;仅指定基类类型&#x2F;泛型</td>
</tr>
</tbody></table>
<p>优劣分析:</p>
<ul>
<li><p>中心式事件中心好理解就不再赘述, 分布式是其实就是把事件中心作为事件发送者的一个成员变量存在. 这样相比于需要中心统一发送再由接收者判断发送者来说可以省略判断发送者的步骤, 也可以降低事件中心的处理压力. 同时因为分散增加了定位问题的难度, 多个池子也不利于管理.</p>
</li>
<li><p>事件类型与事件参数的关系可以用两个函数来简单说明</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"><span class="built_in">int</span> EventId, <span class="built_in">object</span> arg</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params">EventArgs arg</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面的将事件类型与事件参数分离了, 下面的就是统一的. 这个的优劣不是很明显, 见仁见智.</p>
</li>
<li><p>多事件参数通常出现在事件类型与事件参数分离的情况下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如参数依次为: 玩家获得金钱事件, 触发的玩家, 金钱的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"><span class="built_in">int</span> EventId, <span class="built_in">object</span> arg0, <span class="built_in">object</span> arg1</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个的问题就很明显:</p>
<ul>
<li>首先事件中心需要声明许多因参数数量产生的重载. 又因为不能限制参数类型所以只能用 object , object 与值类型会产生装箱拆箱. 好处是一个 params 关键字解决 Fire 函数的重载问题, 但 Subscribe &#x2F; UnSubscribe 函数就没这么好运了. </li>
<li>如果不想经历装箱拆箱就得用泛型. 但坏处就是没法用 params 关键字解决 Fire 函数的重载问题了.</li>
<li>使用时必须记住每个事件对应的参数数量和参数类型的顺序, 用起来体验极差.</li>
</ul>
<p>所以还是推荐唯一参数, 用复杂类型替代基本类型, 只需要记住一个变量类型, 还能优化 GC.</p>
</li>
<li><p>事件参数的类型</p>
<p>指定事件参数类型一般不会有人用在事件中心, 除非游戏事件非常简单. 或者通过了某种转换传进事件中心.</p>
<p>基类类型和泛型在上面已经提到, 不再赘述.</p>
</li>
</ul>
<h1 id="知识点图"><a href="#知识点图" class="headerlink" title="知识点图"></a>知识点图</h1><p>事件中心因为其完全不依赖 Unity 就能实现, 所以完全归属于 GF 中, 是编程设计模式中观察者模式的经典用例, 非常强大的解耦工具. 注意是非非非非非常强大的解耦工具. 网络那块只是稍微所有涉猎, 这里卖个萌以后再讲吧. 下一篇, 咱来讲任务异步.</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuyuko-C/BlogAsset@master/img/GameFramework-3.0.jpg" alt="GameFramework-3.0"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Game-Framework/">Game Framework</a></div><div class="post_share"><div class="social-share" data-image="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/GameFramework-4/"><img class="prev-cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Game Framework - 任务异步</div></div></a></div><div class="next-post pull-right"><a href="/SyncProcess/"><img class="next-cover" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/GameFramework-0/" title="Game Framework - 概述"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">Game Framework - 概述</div></div></a></div><div><a href="/GameFramework-2/" title="Game Framework - 内存管理"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Game Framework - 内存管理</div></div></a></div><div><a href="/GameFramework-1/" title="Game Framework - 生命周期"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-18</div><div class="title">Game Framework - 生命周期</div></div></a></div><div><a href="/GameFramework-4/" title="Game Framework - 任务异步"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-08</div><div class="title">Game Framework - 任务异步</div></div></a></div><div><a href="/GameFramework-5/" title="Game Framework - Web请求与下载"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">Game Framework - Web请求与下载</div></div></a></div><div><a href="/GameFramework-6/" title="Game Framework - 资源管理"><img class="cover" src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">Game Framework - 资源管理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/yuyuko_avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">西行寺幽幽子</div><div class="author-info__description">愿于春日樱下死, 阴历二月满月时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuyuko-C"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuyuko-C" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1061439585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">头像是我老婆, 养不起的那种.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">1.</span> <span class="toc-text">事件中心的由来</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">事件中心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GameFramework-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83"><span class="toc-number">3.</span> <span class="toc-text">GameFramework 中的事件中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BaseEventArgs"><span class="toc-number">3.1.</span> <span class="toc-text">BaseEventArgs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event"><span class="toc-number">3.2.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventPool"><span class="toc-number">3.3.</span> <span class="toc-text">EventPool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EventPool-%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">EventPool 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventPool-%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%94%AF%E4%B8%80"><span class="toc-number">4.1.</span> <span class="toc-text">EventPool 为何不唯一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventPool-%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">EventPool 的运作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-number">4.2.2.</span> <span class="toc-text">事件触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FireNow-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">FireNow 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fire-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">Fire 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.5.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85"><span class="toc-number">4.2.6.</span> <span class="toc-text">事件中取消订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.7.</span> <span class="toc-text">其他成员变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8-%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">延伸: 事件中心的几种模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">知识点图</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-6/" title="Game Framework - 资源管理"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - 资源管理"/></a><div class="content"><a class="title" href="/GameFramework-6/" title="Game Framework - 资源管理">Game Framework - 资源管理</a><time datetime="2023-03-08T18:07:13.000Z" title="发表于 2023-03-09 02:07:13">2023-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DotNetDataAnalysis/" title=".Net 平台的数据分析解决方案"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=".Net 平台的数据分析解决方案"/></a><div class="content"><a class="title" href="/DotNetDataAnalysis/" title=".Net 平台的数据分析解决方案">.Net 平台的数据分析解决方案</a><time datetime="2023-03-01T15:12:57.000Z" title="发表于 2023-03-01 23:12:57">2023-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/VSCodeShortcutKey/" title="Visual Studio Code 快捷键大全"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.o2GaQOb9UbzNIrWO3S7hWwHaDt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Visual Studio Code 快捷键大全"/></a><div class="content"><a class="title" href="/VSCodeShortcutKey/" title="Visual Studio Code 快捷键大全">Visual Studio Code 快捷键大全</a><time datetime="2023-02-27T02:05:27.000Z" title="发表于 2023-02-27 10:05:27">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-5/" title="Game Framework - Web请求与下载"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - Web请求与下载"/></a><div class="content"><a class="title" href="/GameFramework-5/" title="Game Framework - Web请求与下载">Game Framework - Web请求与下载</a><time datetime="2023-01-30T12:10:42.000Z" title="发表于 2023-01-30 20:10:42">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/GameFramework-4/" title="Game Framework - 任务异步"><img src="https://picd.zhimg.com/v2-e8aa629dc3c0a76244b02ce23e36dc15_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Game Framework - 任务异步"/></a><div class="content"><a class="title" href="/GameFramework-4/" title="Game Framework - 任务异步">Game Framework - 任务异步</a><time datetime="2022-12-08T03:57:55.000Z" title="发表于 2022-12-08 11:57:55">2022-12-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 西行寺幽幽子</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>